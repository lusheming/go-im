<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>go-im æµ‹è¯•å°</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #0ea5e9;
      --primary-dark: #0284c7;
      --success: #10b981;
      --success-dark: #059669;
      --danger: #ef4444;
      --warning: #f59e0b;
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --surface: #1e293b;
      --surface-hover: #334155;
      --border: #334155;
      --border-light: #475569;
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --text-muted: #94a3b8;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #1e293b 100%);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px 32px;
      margin-bottom: 24px;
      box-shadow: var(--shadow);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary) 0%, var(--success) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header-badge {
      background: var(--bg-tertiary);
      color: var(--text-muted);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 400px 1fr 380px;
      gap: 24px;
      align-items: start;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .card-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--border);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section {
      margin-bottom: 32px;
    }

    .section:last-child {
      margin-bottom: 0;
    }

    .section-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-title::before {
      content: '';
      width: 4px;
      height: 16px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--success) 100%);
      border-radius: 2px;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-row {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      align-items: center;
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .form-grid-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .input-group {
      position: relative;
      flex: 1;
    }

    input, select, textarea {
      width: 100%;
      background: var(--bg-primary);
      border: 2px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      padding: 12px 16px;
      font-size: 14px;
      font-weight: 400;
      transition: all 0.2s ease;
    }

    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
    }

    input::placeholder {
      color: var(--text-muted);
    }

    .btn {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-height: 44px;
      box-shadow: var(--shadow);
    }

    .btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }

    .btn:active:not(:disabled) {
      transform: translateY(0);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    .btn-success {
      background: linear-gradient(135deg, var(--success) 0%, var(--success-dark) 100%);
    }

    .btn-danger {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }

    .btn-small {
      padding: 8px 12px;
      font-size: 12px;
      min-height: 32px;
    }

    .tag {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      padding: 4px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      margin-right: 8px;
    }

    .status-indicator.offline {
      background: var(--text-muted);
    }

    .log-container {
      background: var(--bg-primary);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      height: 200px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre-wrap;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .log-container.ws-log {
      height: 300px;
    }

    .video-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .video-wrapper {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: var(--bg-primary);
      box-shadow: var(--shadow);
      aspect-ratio: 16/9;
    }

    video {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
    }

    .video-label {
      position: absolute;
      bottom: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 10px;
      font-weight: 500;
    }

    .section-subtitle {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 10px;
      border-left: 3px solid var(--primary);
      padding-left: 10px;
    }

    .btn-small {
      padding: 6px 12px;
      font-size: 12px;
    }

    .video-controls {
      position: absolute;
      bottom: 10px;
      right: 10px;
      display: flex;
      gap: 5px;
    }

    .video-control-btn {
      background: rgba(0, 0, 0, 0.7);
      border: none;
      color: white;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }

    .video-control-btn:hover {
      background: rgba(0, 0, 0, 0.9);
    }

    .video-control-btn.active {
      background: var(--danger);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
    }

    .stat-item {
      background: var(--surface);
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-label {
      display: block;
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

          .stat-value {
        display: block;
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
      }

      @keyframes pulse {
        0% { 
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(14, 165, 233, 0.7);
        }
        50% { 
          transform: scale(1.05);
          box-shadow: 0 0 0 10px rgba(14, 165, 233, 0);
        }
        100% { 
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(14, 165, 233, 0);
        }
      }

    .file-list, .favorite-list, .notice-list {
      max-height: 200px;
      overflow-y: auto;
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: var(--bg-primary);
    }

    .file-item, .favorite-item, .notice-item {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .file-item:last-child, .favorite-item:last-child, .notice-item:last-child {
      margin-bottom: 0;
    }

    .typing-indicator {
      color: var(--success);
      font-style: italic;
      margin-left: 12px;
      display: none;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      margin-bottom: 16px;
    }

    .logs-grid {
      display: grid;
      gap: 20px;
    }

    .icon {
      width: 16px;
      height: 16px;
      display: inline-block;
    }

    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 1400px) {
      .main-grid {
        grid-template-columns: 380px 1fr;
      }
      
      .logs-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 1024px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
      
      .form-grid {
        grid-template-columns: 1fr;
      }
      
      .form-grid-3 {
        grid-template-columns: 1fr 1fr;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 12px;
      }
      
      header {
        padding: 16px 20px;
        flex-direction: column;
        gap: 12px;
        text-align: center;
      }
      
      .form-grid-3 {
        grid-template-columns: 1fr;
      }
      
      .video-container {
        flex-direction: column;
      }
    }

    /* æ»šåŠ¨æ¡æ ·å¼ */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--border-light);
    }

    /* åŠ¨ç”» */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .card {
      animation: fadeIn 0.3s ease;
    }

    /* ç¾åŒ–æ–‡ä»¶ä¸Šä¼  */
    .file-upload {
      position: relative;
      display: inline-block;
      cursor: pointer;
      width: 100%;
    }

    .file-upload input[type="file"] {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .file-upload-label {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: var(--bg-primary);
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      transition: all 0.2s ease;
      color: var(--text-muted);
    }

    .file-upload:hover .file-upload-label {
      border-color: var(--primary);
      color: var(--primary);
    }
  </style>
</head>
<body>
  <div class="container">
<header>
      <h1>ğŸš€ go-im æµ‹è¯•å°</h1>
      <div class="header-badge">v2.0 - å®Œæ•´åŠŸèƒ½æµ‹è¯•</div>
</header>

    <div class="main-grid">
      <!-- å·¦ä¾§åŠŸèƒ½åŒº -->
      <div class="card">
        <div class="card-title">
          ğŸ”§ åŠŸèƒ½æ§åˆ¶å°
    </div>

        <!-- è®¤è¯éƒ¨åˆ† -->
        <div class="section">
          <div class="section-title">ğŸ” ç”¨æˆ·è®¤è¯</div>
          <div class="form-group">
            <input id="base" placeholder="Base URLï¼Œä¾‹å¦‚ http://127.0.0.1:8080" value="http://localhost:8080" />
    </div>
          <div class="form-grid">
            <input id="username" placeholder="ç”¨æˆ·å" />
            <input id="password" placeholder="å¯†ç " type="password" />
    </div>
          <div class="form-group">
            <input id="nickname" placeholder="æ˜µç§°(æ³¨å†Œå¯é€‰)" />
    </div>
          <div class="form-grid">
            <button class="btn btn-success" onclick="register()">ğŸ“ æ³¨å†Œ</button>
            <button class="btn" onclick="login()">ğŸ”‘ ç™»å½•</button>
    </div>
          <div class="form-row">
            <span class="tag">Token</span>
            <input id="token" placeholder="JWT token" />
    </div>
          <div class="form-row">
            <span class="tag">UserID</span>
            <input id="userId" placeholder="ç™»å½•è¿”å› userId" />
    </div>
          <div class="form-grid">
            <button class="btn btn-secondary" onclick="me()">ğŸ‘¤ æ›´æ–°èµ„æ–™</button>
            <button class="btn btn-secondary" onclick="queryDevices()">ğŸ“± åœ¨çº¿è®¾å¤‡</button>
    </div>
          
          <!-- WebSocketè¿æ¥ -->
          <div class="form-group" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border);">
            <div class="section-subtitle">ğŸ”Œ WebSocket è¿æ¥</div>
            <div class="connection-status">
              <div class="status-indicator offline" id="wsStatus"></div>
              <span id="wsStatusText">æœªè¿æ¥</span>
    </div>
            <div class="form-row">
              <input id="wsUrl" placeholder="WebSocket URL" value="ws://localhost:8080/ws" />
    </div>
            <div class="form-row">
              <input id="deviceId" placeholder="è®¾å¤‡ IDï¼ˆå¯è‡ªå®šä¹‰ï¼‰" />
              <button class="btn" onclick="wsConnect()" id="wsBtn">ğŸ”Œ è¿æ¥</button>
    </div>
          </div>
        </div>

        <!-- å¥½å‹ç¾¤ç»„ -->
        <div class="section">
          <div class="section-title">ğŸ‘¥ å¥½å‹ & ç¾¤ç»„</div>
          <div class="form-row">
            <input id="friendId" placeholder="å¥½å‹ ID" />
            <button class="btn btn-success" onclick="addFriend()">â• åŠ å¥½å‹</button>
          </div>
          <div class="form-row">
            <input id="groupName" placeholder="ç¾¤ç»„åç§°" />
            <button class="btn btn-success" onclick="createGroup()">ğŸ—ï¸ åˆ›å»ºç¾¤</button>
          </div>
          <div class="form-row">
            <input id="groupId" placeholder="ç¾¤ç»„ ID" />
            <button class="btn" onclick="joinGroup()">ğŸšª åŠ å…¥ç¾¤</button>
          </div>
        </div>

        <!-- ä¼šè¯ç®¡ç† -->
        <div class="section">
          <div class="section-title">ğŸ’¬ ä¼šè¯ç®¡ç†</div>
          <div class="form-grid">
            <button class="btn btn-secondary" onclick="listConvs()">ğŸ“‹ ä¼šè¯åˆ—è¡¨</button>
            <button class="btn btn-secondary" onclick="unreadSummary()">ğŸ”” æœªè¯»æ±‡æ€»</button>
          </div>
          <div class="form-row">
            <input id="convId" placeholder="ä¼šè¯ ID" />
            <button class="btn" onclick="markAllRead()">âœ… å…¨éƒ¨å·²è¯»</button>
          </div>
          <div class="form-row">
            <input id="pinConvId" placeholder="ä¼šè¯ ID" />
            <button class="btn btn-secondary" onclick="pinConv(true)">ğŸ“Œ ç½®é¡¶</button>
            <button class="btn btn-secondary" onclick="pinConv(false)">ğŸ“Œ å–æ¶ˆç½®é¡¶</button>
          </div>
          <div class="form-row">
            <input id="muteConvId" placeholder="ä¼šè¯ ID" />
            <button class="btn btn-secondary" onclick="muteConv(true)">ğŸ”‡ å…æ‰“æ‰°</button>
            <button class="btn btn-secondary" onclick="muteConv(false)">ğŸ”Š å–æ¶ˆå…æ‰“æ‰°</button>
          </div>
          <div class="form-group">
            <input id="draftConvId" placeholder="è‰ç¨¿ä¼šè¯ ID" />
          </div>
          <div class="form-row">
      <input id="draftText" placeholder="è‰ç¨¿å†…å®¹" />
            <button class="btn" onclick="setDraft()">ğŸ’¾ ä¿å­˜è‰ç¨¿</button>
    </div>
    </div>



        <!-- æ¶ˆæ¯å‘é€ -->
        <div class="section">
          <div class="section-title">ğŸ’Œ æ¶ˆæ¯å‘é€</div>
          <div class="form-group">
            <input id="sendTo" placeholder="æ¥æ”¶ç”¨æˆ· IDï¼ˆå•èŠï¼‰" />
    </div>
          <div class="form-row">
            <input id="sendGroupId" placeholder="ç¾¤ç»„ IDï¼ˆç¾¤èŠï¼‰" />
            <button class="btn btn-secondary" onclick="subscribeGroup()">ğŸ‘‚ è®¢é˜…ç¾¤</button>
    </div>
          <div class="form-row">
      <select id="convType">
              <option value="c2c">ğŸ‘¤ å•èŠ (C2C)</option>
              <option value="group">ğŸ‘¥ ç¾¤èŠ (Group)</option>
      </select>
            <input id="clientMsgId" placeholder="å®¢æˆ·ç«¯æ¶ˆæ¯ ID" />
    </div>
          <div class="form-row">
      <input id="payloadText" placeholder="æ–‡æœ¬å†…å®¹" />
            <span class="typing-indicator" id="peerTyping">å¯¹æ–¹æ­£åœ¨è¾“å…¥...</span>
    </div>
          <button class="btn btn-success" onclick="wsSendText()" id="sendBtn" disabled>ğŸ“¤ å‘é€æ¶ˆæ¯</button>
        </div>

        <!-- æµå¼æ¶ˆæ¯ -->
        <div class="section">
          <div class="section-title">ğŸŒŠ æµå¼æ¶ˆæ¯</div>
          <div class="form-row">
      <input id="streamText" placeholder="æµå¼æ¶ˆæ¯åˆå§‹å†…å®¹" />
            <button class="btn" onclick="startStream()" id="startStreamBtn" disabled>ğŸš€ å¼€å§‹æµå¼</button>
    </div>
          <div class="form-row">
      <input id="streamDelta" placeholder="å¢é‡æ–‡æœ¬" />
            <button class="btn btn-secondary" onclick="sendChunk()" id="chunkBtn" disabled>ğŸ“„ å‘é€ç‰‡æ®µ</button>
            <button class="btn btn-danger" onclick="endStream()" id="endStreamBtn" disabled>ğŸ›‘ ç»“æŸæµå¼</button>
    </div>
          <div class="form-row">
            <span class="tag">StreamID</span>
            <input id="currentStreamId" placeholder="å½“å‰æµ ID" readonly />
    </div>
        </div>
      </div>

      <!-- ä¸­é—´åŠŸèƒ½åŒº -->
      <div class="card">
        <div class="card-title">
          ğŸ¯ é«˜çº§åŠŸèƒ½
        </div>

        <!-- éŸ³è§†é¢‘é€šè¯ -->
        <div class="section">
          <div class="section-title">ğŸ“ éŸ³è§†é¢‘é€šè¯</div>
          
          <!-- è®¾å¤‡é€‰æ‹© -->
          <div class="form-group">
            <div class="section-subtitle">ğŸ›ï¸ è®¾å¤‡é€‰æ‹©</div>
            <div class="form-row">
              <select id="cameraSelect">
                <option value="">ğŸ“¹ é€‰æ‹©æ‘„åƒå¤´</option>
              </select>
              <select id="microphoneSelect">
                <option value="">ğŸ™ï¸ é€‰æ‹©éº¦å…‹é£</option>
              </select>
              <button class="btn btn-small" onclick="refreshDevices()">ğŸ”„ åˆ·æ–°è®¾å¤‡</button>
            </div>
          </div>

          <!-- é€šè¯æ§åˆ¶ -->
          <div class="form-group">
            <div class="section-subtitle">â˜ï¸ é€šè¯æ§åˆ¶</div>
            <div class="form-row">
              <input id="callTo" placeholder="é€šè¯å¯¹è±¡ ID" />
      <select id="callType">
                <option value="audio">ğŸ™ï¸ è¯­éŸ³é€šè¯</option>
                <option value="video">ğŸ“¹ è§†é¢‘é€šè¯</option>
      </select>
    </div>
            <div class="form-grid">
              <button class="btn btn-success" onclick="startCall()" id="startCallBtn" disabled>ğŸ“ å‘èµ·é€šè¯</button>
              <button class="btn" onclick="answerCall()" id="answerBtn" disabled>âœ… æ¥å¬</button>
              <button class="btn btn-danger" onclick="rejectCall()" id="rejectBtn" disabled>âŒ æ‹’æ¥</button>
              <button class="btn btn-danger" onclick="endCall()" id="endBtn" disabled>ğŸ“µ æŒ‚æ–­</button>
    </div>
    </div>

          <!-- åª’ä½“æ§åˆ¶ -->
          <div class="form-group" id="mediaControls" style="display: none;">
            <div class="section-subtitle">ğŸ›ï¸ åª’ä½“æ§åˆ¶</div>
            <div class="form-grid">
              <button class="btn" onclick="toggleMute()" id="muteBtn">ğŸ™ï¸ é™éŸ³</button>
              <button class="btn" onclick="toggleVideo()" id="videoBtn">ğŸ“¹ å…³é—­è§†é¢‘</button>
              <button class="btn" onclick="shareScreen()" id="screenBtn">ğŸ–¥ï¸ å…±äº«å±å¹•</button>
              <button class="btn" onclick="testDevices()" id="testBtn">ğŸ§ª è®¾å¤‡æµ‹è¯•</button>
    </div>
    </div>
    
          <!-- é€šè¯çŠ¶æ€ -->
          <div class="form-group">
            <div class="section-subtitle">ğŸ“Š é€šè¯çŠ¶æ€</div>
            <div class="form-row">
              <span class="tag">CallID</span>
              <input id="currentCallId" placeholder="å½“å‰é€šè¯ ID" readonly />
            </div>
            <div class="form-row">
              <span class="tag">çŠ¶æ€</span>
              <input id="callStatus" placeholder="é€šè¯çŠ¶æ€" readonly />
            </div>
            <div class="form-row">
              <span class="tag">è¿æ¥</span>
              <input id="connectionState" placeholder="è¿æ¥çŠ¶æ€" readonly />
            </div>
            <div class="form-row">
              <span class="tag">ç½‘ç»œ</span>
              <input id="networkQuality" placeholder="ç½‘ç»œè´¨é‡" readonly />
            </div>
          </div>

          <!-- è§†é¢‘çª—å£ -->
          <div class="video-container">
            <div class="video-wrapper">
              <video id="localVideo" autoplay muted></video>
              <div class="video-label">æœ¬åœ°</div>
              <div class="video-controls">
                <button class="video-control-btn" onclick="toggleLocalMute()" id="localMuteBtn">ğŸ™ï¸</button>
                <button class="video-control-btn" onclick="toggleLocalVideo()" id="localVideoBtn">ğŸ“¹</button>
              </div>
            </div>
            <div class="video-wrapper">
              <video id="remoteVideo" autoplay></video>
              <div class="video-label">è¿œç¨‹</div>
              <div class="video-controls">
                <button class="video-control-btn" onclick="toggleFullscreen('remoteVideo')" id="fullscreenBtn">â›¶</button>
              </div>
            </div>
          </div>

          <!-- é€šè¯ç»Ÿè®¡ -->
          <div class="form-group" id="callStats" style="display: none;">
            <div class="section-subtitle">ğŸ“ˆ é€šè¯ç»Ÿè®¡</div>
            <div class="stats-grid">
              <div class="stat-item">
                <span class="stat-label">éŸ³é¢‘ç ç‡</span>
                <span class="stat-value" id="audioBitrate">- kbps</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">è§†é¢‘ç ç‡</span>
                <span class="stat-value" id="videoBitrate">- kbps</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">ä¸¢åŒ…ç‡</span>
                <span class="stat-value" id="packetLoss">- %</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">å»¶è¿Ÿ</span>
                <span class="stat-value" id="latency">- ms</span>
              </div>
            </div>
          </div>
        </div>

        <!-- å¤šåª’ä½“æ¶ˆæ¯ -->
        <div class="section">
          <div class="section-title">ğŸ¨ å¤šåª’ä½“æ¶ˆæ¯</div>
          <div class="form-group">
      <select id="messageType">
              <option value="text">ğŸ“ æ–‡æœ¬æ¶ˆæ¯</option>
              <option value="image">ğŸ–¼ï¸ å›¾ç‰‡æ¶ˆæ¯</option>
              <option value="voice">ğŸµ è¯­éŸ³æ¶ˆæ¯</option>
              <option value="video">ğŸ¬ è§†é¢‘æ¶ˆæ¯</option>
              <option value="file">ğŸ“ æ–‡ä»¶æ¶ˆæ¯</option>
              <option value="card">ğŸ‘¤ åç‰‡æ¶ˆæ¯</option>
              <option value="location">ğŸ“ ä½ç½®æ¶ˆæ¯</option>
      </select>
    </div>
          <div class="form-group" id="textMessage">
      <input id="msgText" placeholder="æ¶ˆæ¯å†…å®¹" />
    </div>
          <div class="form-group" id="fileMessage" style="display:none">
            <div class="file-upload">
      <input type="file" id="fileInput" />
              <div class="file-upload-label">
                ğŸ“ é€‰æ‹©æ–‡ä»¶ä¸Šä¼ 
    </div>
            </div>
            <button class="btn" onclick="uploadFile()" id="uploadBtn">â¬†ï¸ ä¸Šä¼ æ–‡ä»¶</button>
          </div>
          <div id="cardMessage" style="display:none">
            <div class="form-grid-3">
      <input id="cardUserId" placeholder="åç‰‡ç”¨æˆ·ID" />
      <input id="cardNickname" placeholder="åç‰‡æ˜µç§°" />
      <input id="cardAvatar" placeholder="åç‰‡å¤´åƒURL" />
    </div>
          </div>
          <div id="locationMessage" style="display:none">
            <div class="form-grid-3">
      <input id="locLatitude" placeholder="çº¬åº¦" type="number" step="any" />
      <input id="locLongitude" placeholder="ç»åº¦" type="number" step="any" />
      <input id="locAddress" placeholder="åœ°å€æè¿°" />
    </div>
          </div>
          <button class="btn btn-success" onclick="sendMessage()" id="sendMessageBtn" disabled>ğŸ“¤ å‘é€æ¶ˆæ¯</button>
    </div>
    
        <!-- æ–‡ä»¶ç®¡ç† -->
        <div class="section">
          <div class="section-title">ğŸ“‚ æ–‡ä»¶ç®¡ç†</div>
          <div class="form-grid">
            <button class="btn btn-secondary" onclick="listFiles()">ğŸ“‹ æˆ‘çš„æ–‡ä»¶</button>
            <button class="btn btn-secondary" onclick="clearFileList()">ğŸ—‘ï¸ æ¸…ç©ºåˆ—è¡¨</button>
    </div>
          <div id="fileList" class="file-list"></div>
        </div>

        <!-- æ”¶è—ç®¡ç† -->
        <div class="section">
          <div class="section-title">â­ æ”¶è—ç®¡ç†</div>
          <div class="form-row">
      <input id="favoriteTitle" placeholder="æ”¶è—æ ‡é¢˜" />
      <input id="favoriteTags" placeholder="æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰" />
            <button class="btn btn-success" onclick="favoriteCustom()">â­ æ”¶è—</button>
    </div>
          <div class="form-grid">
      <input id="favoriteSearch" placeholder="æœç´¢æ”¶è—" />
            <button class="btn btn-secondary" onclick="searchFavorites()">ğŸ” æœç´¢</button>
    </div>
          <div class="form-grid">
            <button class="btn btn-secondary" onclick="listFavorites()">ğŸ“‹ æˆ‘çš„æ”¶è—</button>
            <button class="btn btn-secondary" onclick="favoriteStats()">ğŸ“Š æ”¶è—ç»Ÿè®¡</button>
          </div>
          <div id="favoriteList" class="favorite-list"></div>
        </div>

        <!-- ç¾¤æ‰©å±•åŠŸèƒ½ -->
        <div class="section">
          <div class="section-title">ğŸ‘¥ ç¾¤æ‰©å±•åŠŸèƒ½</div>
          <div class="form-row">
            <input id="mentionUsers" placeholder="@æˆå‘˜ userIdï¼ˆé€—å·åˆ†éš”ï¼‰" />
            <button class="btn" onclick="sendMention()" id="mentionBtn" disabled>ğŸ“¢ @å‘é€</button>
    </div>
          <div class="form-row">
      <input id="muteGroupId" placeholder="ç¾¤ID" />
            <select id="muteOn">
              <option value="true">ğŸ”‡ å…¨å‘˜ç¦è¨€ å¼€</option>
              <option value="false">ğŸ”Š å…¨å‘˜ç¦è¨€ å…³</option>
            </select>
            <button class="btn" onclick="setGroupMute()">âš™ï¸ è®¾ç½®ç¦è¨€</button>
    </div>
          <div class="form-group">
      <input id="noticeGroupId" placeholder="ç¾¤ID" />
          </div>
          <div class="form-row">
      <input id="noticeTitle" placeholder="å…¬å‘Šæ ‡é¢˜" />
      <input id="noticeContent" placeholder="å…¬å‘Šå†…å®¹" />
    </div>
          <div class="form-grid">
            <button class="btn btn-success" onclick="createNotice()">ğŸ“¢ å‘å¸ƒå…¬å‘Š</button>
            <button class="btn btn-secondary" onclick="listNotices()">ğŸ“‹ æ‹‰å–å…¬å‘Š</button>
          </div>
          <div id="noticeList" class="notice-list"></div>
        </div>

        <!-- OSS ç›´ä¼  -->
        <div class="section">
          <div class="section-title">â˜ï¸ OSS ç›´ä¼ </div>
          <div class="form-row">
            <div class="file-upload">
      <input type="file" id="ossFile" />
              <div class="file-upload-label">
                â˜ï¸ é€‰æ‹© OSS ä¸Šä¼ æ–‡ä»¶
    </div>
    </div>
            <input id="ossDir" placeholder="ç›®å½•å‰ç¼€ï¼ˆå¯é€‰ï¼‰" />
          </div>
          <button class="btn" onclick="ossDirectUpload()" id="ossUploadBtn">â˜ï¸ OSS ç›´ä¼ </button>
          <div class="form-row">
            <span class="tag">ç»“æœ</span>
      <input id="ossUploadURL" placeholder="ç›´ä¼ URL" readonly />
    </div>
        </div>
      </div>

      <!-- å³ä¾§æ—¥å¿—åŒº -->
      <div class="logs-grid">
        <div class="card">
          <div class="card-title">
            ğŸ“Š ç³»ç»Ÿæ—¥å¿—
          </div>
          <div id="log" class="log-container"></div>
        </div>
        
        <div class="card">
          <div class="card-title">
            ğŸ”Œ WebSocket æ”¶å‘
          </div>
          <div id="wslog" class="log-container ws-log"></div>
        </div>
      </div>
    </div>
  </div>

<script>
let ws;
// è‡ªåŠ¨é‡è¿å‚æ•°
let wsReconnectDelay = 1000; // 1s èµ·æ­¥
const wsReconnectMaxDelay = 15000; // ä¸Šé™ 15s
let wsReconnectTimer = null;

// WebRTC å¢å¼ºå˜é‡
let availableDevices = { cameras: [], microphones: [] };
let currentStream = null;
let isAudioMuted = false;
let isVideoMuted = false;
let isScreenSharing = false;
let callStatsInterval = null;

function log(msg){ const el=document.getElementById('log'); el.textContent += `\n${new Date().toLocaleTimeString()} ${msg}`; el.scrollTop=el.scrollHeight; }
function wslog(msg){ const el=document.getElementById('wslog'); el.textContent += `\n${new Date().toLocaleTimeString()} ${msg}`; el.scrollTop=el.scrollHeight; }

function base(){ return document.getElementById('base').value || location.origin }
function authHeader(){ const t=document.getElementById('token').value; return t? { 'Authorization': 'Bearer '+t } : {} }
async function post(path, body){ const r = await fetch(base()+path, {method:'POST', headers:{'Content-Type':'application/json',...authHeader()}, body:JSON.stringify(body||{})}); const j= await r.json().catch(()=>({})); log(`[POST] ${path} â†’ ${r.status} ${JSON.stringify(j)}`); return j }
async function put(path, body){ const r = await fetch(base()+path, {method:'PUT', headers:{'Content-Type':'application/json',...authHeader()}, body:JSON.stringify(body||{})}); log(`[PUT] ${path} â†’ ${r.status}`) }
async function del(path){ const r = await fetch(base()+path, {method:'DELETE', headers:{...authHeader()}}); log(`[DELETE] ${path} â†’ ${r.status}`) }
async function get(path){ const r = await fetch(base()+path, {headers:{...authHeader()}}); const j= await r.json().catch(()=>({})); log(`[GET] ${path} â†’ ${r.status} ${JSON.stringify(j)}`); return j }

async function register(){ const j=await post('/api/register',{username:val('username'),password:val('password'),nickname:val('nickname')}); }
async function login(){ 
  const j=await post('/api/login',{username:val('username'),password:val('password')}); 
  if(j.token){ 
    setVal('token', j.token); 
    setVal('userId', j.userId);
    log('âœ… ç™»å½•æˆåŠŸï¼è¯·ç‚¹å‡»ä¸‹æ–¹"ğŸ”Œ è¿æ¥"æŒ‰é’®è¿æ¥WebSocket');
    
    // é«˜äº®WebSocketè¿æ¥æŒ‰é’®
    const wsBtn = document.getElementById('wsBtn');
    if (wsBtn) {
      wsBtn.style.animation = 'pulse 2s infinite';
      setTimeout(() => { 
        if (wsBtn.style.animation) wsBtn.style.animation = ''; 
      }, 6000);
    }
  } 
}
async function me(){ await put('/api/users/me',{nickname:val('nickname'),avatarUrl:''}) }
async function addFriend(){ await post('/api/friends',{friendID:val('friendId'),remark:''}) }
async function createGroup(){ const j=await post('/api/groups',{name:val('groupName')}); if(j.groupId) setVal('groupId', j.groupId) }
async function joinGroup(){ await post(`/api/groups/${val('groupId')}/join`) }
async function listConvs(){ await get('/api/conversations?limit=50') }
async function unreadSummary(){ await get('/api/unread/summary') }
async function markAllRead(){ await post('/api/unread/mark_all_read') }
async function pinConv(on){ await post(`/api/conversations/${val('pinConvId')}/pin`,{pinned:on}) }
async function muteConv(on){ await post(`/api/conversations/${val('muteConvId')}/mute`,{muted:on}) }
async function setDraft(){ await post(`/api/conversations/${val('draftConvId')}/draft`,{draft:val('draftText')}) }
async function queryDevices(){ await get('/api/users/me/devices') }

function updateConnectionStatus(connected) {
  const statusEl = document.getElementById('wsStatus');
  const textEl = document.getElementById('wsStatusText');
  if (connected) {
    statusEl.classList.remove('offline');
    textEl.textContent = 'å·²è¿æ¥';
  } else {
    statusEl.classList.add('offline');
    textEl.textContent = 'æœªè¿æ¥';
  }
}

function wsConnect(){
  // æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
  const token = val('token');
  if (!token) {
    log('âŒ è¯·å…ˆç™»å½•å†è¿æ¥WebSocket');
    return;
  }
  
  // å…³é—­æ—§è¿æ¥å¹¶æ¸…ç†é‡è¿è®¡æ—¶å™¨
  if(ws){ try{ ws.close() }catch{} ws=undefined }
  if(wsReconnectTimer){ clearTimeout(wsReconnectTimer); wsReconnectTimer=null }
  
  const url=(document.getElementById('wsUrl').value||`${location.origin.replace('http','ws')}/ws`)+`?token=${token}&deviceId=${encodeURIComponent(val('deviceId')||('web-'+Date.now()))}`;
  
  log('ğŸ”Œ æ­£åœ¨è¿æ¥WebSocket...');
  ws=new WebSocket(url);
  
  ws.onopen=()=>{ 
    wslog('âœ… WebSocketè¿æ¥æˆåŠŸ'); 
    log('ğŸ‰ WebSocketå·²è¿æ¥ï¼Œç°åœ¨å¯ä»¥æ”¶å‘æ¶ˆæ¯äº†ï¼');
    enableSend(true); 
    wsReconnectDelay=1000; 
    if(wsReconnectTimer){ clearTimeout(wsReconnectTimer); wsReconnectTimer=null } 
    updateConnectionStatus(true); 
  };
  
  ws.onclose=()=>{ 
    wslog('âŒ WebSocketè¿æ¥å·²å…³é—­'); 
    log('ğŸ”Œ WebSocketè¿æ¥å·²æ–­å¼€');
    enableSend(false); 
    scheduleWsReconnect(); 
    updateConnectionStatus(false); 
  };
  
  ws.onerror=(e)=>{ 
    wslog('âŒ WebSocketè¿æ¥é”™è¯¯'); 
    log('âŒ WebSocketè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’ŒæœåŠ¡å™¨çŠ¶æ€');
    scheduleWsReconnect(); 
    updateConnectionStatus(false); 
  };
  
  ws.onmessage=(ev)=>{ wslog('â† '+ev.data); handleWSMessage(ev.data) };
}

function scheduleWsReconnect(){
  if(wsReconnectTimer) return;
  const delay = wsReconnectDelay;
  wslog(`WS å°†åœ¨ ${delay}ms åé‡è¿...`);
  wsReconnectTimer = setTimeout(()=>{
    wsReconnectTimer = null;
    wsConnect();
    wsReconnectDelay = Math.min(wsReconnectDelay * 2, wsReconnectMaxDelay);
  }, delay);
}

function enableStreamBtns(streaming){ document.getElementById('chunkBtn').disabled=!streaming; document.getElementById('endStreamBtn').disabled=!streaming; }

let peerConnection, localStream, remoteStream;
let currentCall = null;
let iceServers = [];
let pendingCandidates = [];

// WebRTC åˆå§‹åŒ–
async function initWebRTC() {
  try {
    const resp = await get('/api/webrtc/ice-servers');
    if (resp.iceServers) { iceServers = resp.iceServers; }
  } catch (e) { console.log('ICE servers not available:', e); }
}

// åˆ›å»º PeerConnection
function createPeerConnection() {
  const config = { iceServers: iceServers.length > 0 ? iceServers : [{ urls: 'stun:stun.l.google.com:19302' }] };
  peerConnection = new RTCPeerConnection(config);
  
  peerConnection.onicecandidate = (event) => {
    if (event.candidate && currentCall) {
      const c = event.candidate.toJSON ? event.candidate.toJSON() : event.candidate;
      const msg = { action: 'webrtc_signaling', data: { callId: currentCall.id, type: 'candidate', candidate: c, to: getOtherUserId() } };
      ws.send(JSON.stringify(msg));
      wslog('â†’ ICE Candidate');
    }
  };
  
  peerConnection.ontrack = (event) => {
    wslog('â† æ”¶åˆ°è¿œç¨‹æµ');
    const remoteVideo = document.getElementById('remoteVideo');
    if (remoteVideo) { remoteVideo.srcObject = event.streams[0]; }
  };
  
  // è¿æ¥çŠ¶æ€ç›‘æ§
  peerConnection.onconnectionstatechange = () => {
    const state = peerConnection.connectionState;
    wslog(`è¿æ¥çŠ¶æ€å˜æ›´: ${state}`);
    document.getElementById('connectionState').value = state;
    
    if (state === 'connected') {
      wslog('ğŸ‰ WebRTCè¿æ¥å»ºç«‹æˆåŠŸ');
    } else if (state === 'failed' || state === 'disconnected') {
      wslog('âŒ WebRTCè¿æ¥å¤±è´¥æˆ–æ–­å¼€');
    }
  };
  
  // ICEè¿æ¥çŠ¶æ€ç›‘æ§
  peerConnection.oniceconnectionstatechange = () => {
    wslog(`ICEè¿æ¥çŠ¶æ€: ${peerConnection.iceConnectionState}`);
  };
  
  return peerConnection;
}

// å¤„ç†WebRTCä¿¡ä»¤
async function handleSignalingMessage(data) {
  try {
    if (!peerConnection && data.type === 'offer') {
      createPeerConnection();
      if (localStream) {
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
      }
    }

    switch (data.type) {
      case 'offer':
        await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: data.sdp }));
        // è®¾ç½®è¿œç«¯åï¼ŒæŠŠç¼“å­˜çš„å€™é€‰è¡¥ä¸Š
        for (const c of pendingCandidates) {
          try { await peerConnection.addIceCandidate(new RTCIceCandidate(c)); } catch {}
        }
        pendingCandidates = [];
        // ç”Ÿæˆå¹¶å‘é€ answer
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        ws.send(JSON.stringify({ action: 'webrtc_signaling', data: { callId: currentCall.id, type: 'answer', sdp: answer.sdp, to: getOtherUserId() } }));
        wslog('â†’ å‘é€Answer');
        break;
      case 'answer':
        await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: data.sdp }));
        break;
      case 'candidate':
        if (!peerConnection || !peerConnection.remoteDescription) {
          pendingCandidates.push(data.candidate);
        } else {
          try { await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate)); } catch (e) { wslog('æ·»åŠ ICEå¤±è´¥: '+e.message); }
        }
        break;
    }
  } catch (e) {
    wslog('å¤„ç†ä¿¡ä»¤å¤±è´¥: ' + e.message);
  }
}

// è·å–æœ¬åœ°åª’ä½“æµ
async function getLocalStream(video = false) {
  try {
    // è·å–é€‰æ‹©çš„è®¾å¤‡ID
    const cameraId = document.getElementById('cameraSelect').value;
    const micId = document.getElementById('microphoneSelect').value;
    
    const constraints = { 
      audio: micId ? { deviceId: micId } : true,
      video: video ? (cameraId ? { deviceId: cameraId } : true) : false
    };
    
    localStream = await navigator.mediaDevices.getUserMedia(constraints);
    currentStream = localStream; // ä¿å­˜å¼•ç”¨
    
    const localVideo = document.getElementById('localVideo');
    if (localVideo) { localVideo.srcObject = localStream; }
    
    wslog(`åª’ä½“æµè·å–æˆåŠŸ: éŸ³é¢‘=${!!localStream.getAudioTracks().length}, è§†é¢‘=${!!localStream.getVideoTracks().length}`);
    return localStream;
  } catch (e) { 
    wslog('è·å–åª’ä½“æµå¤±è´¥: ' + e.message); 
    throw e; 
  }
}

// å‘èµ·é€šè¯
async function startCall() {
  const to = val('callTo'); const type = val('callType');
  if (!to) { wslog('ERROR: è¯·å¡«å†™é€šè¯å¯¹è±¡'); return; }
  
  try {
    await getLocalStream(type === 'video');
    const msg = { action: 'call_start', data: { to, type } };
    ws.send(JSON.stringify(msg)); wslog('â†’ å‘èµ·é€šè¯: ' + to);
  } catch (e) { wslog('ERROR: å‘èµ·é€šè¯å¤±è´¥: ' + e.message); }
}

// æ¥å¬é€šè¯
async function answerCall() {
  if (!currentCall) { wslog('ERROR: æ— é€šè¯å¯æ¥å¬'); return; }
  
  try {
    await getLocalStream(currentCall.type === 'video');
    createPeerConnection();
    
    // æ·»åŠ æœ¬åœ°æµ
    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
    
    const msg = { action: 'call_answer', data: { callId: currentCall.id } };
    ws.send(JSON.stringify(msg)); wslog('â†’ æ¥å¬é€šè¯');
  } catch (e) { wslog('ERROR: æ¥å¬å¤±è´¥: ' + e.message); }
}

// æ‹’æ¥é€šè¯
function rejectCall() {
  if (!currentCall) return;
  const msg = { action: 'call_reject', data: { callId: currentCall.id } };
  ws.send(JSON.stringify(msg)); wslog('â†’ æ‹’æ¥é€šè¯');
}

// æŒ‚æ–­é€šè¯
function endCall() {
  if (!currentCall) return;
  const msg = { action: 'call_end', data: { callId: currentCall.id } };
  ws.send(JSON.stringify(msg)); wslog('â†’ æŒ‚æ–­é€šè¯');
  cleanupCall();
}

// æ¸…ç†é€šè¯èµ„æº
function cleanupCall() {
  if (peerConnection) { peerConnection.close(); peerConnection = null; }
  if (localStream) { localStream.getTracks().forEach(track => track.stop()); localStream = null; }
  const localVideo = document.getElementById('localVideo'); if (localVideo) localVideo.srcObject = null;
  const remoteVideo = document.getElementById('remoteVideo'); if (remoteVideo) remoteVideo.srcObject = null;
  currentCall = null; setVal('currentCallId', ''); setVal('callStatus', ''); updateCallButtons();
}

// è·å–å¯¹æ–¹ç”¨æˆ·ID
function getOtherUserId() {
  if (!currentCall) return '';
  return currentCall.fromUserId === val('userId') ? currentCall.toUserId : currentCall.fromUserId;
}

// æ›´æ–°é€šè¯æŒ‰é’®çŠ¶æ€
function updateCallButtons() {
  const hasCall = !!currentCall;
  const isIncoming = hasCall && currentCall.fromUserId !== val('userId') && currentCall.status === 'calling';
  document.getElementById('startCallBtn').disabled = hasCall;
  document.getElementById('answerBtn').disabled = !isIncoming;
  document.getElementById('rejectBtn').disabled = !isIncoming;
  document.getElementById('endBtn').disabled = !hasCall;
  
  // æ˜¾ç¤º/éšè—åª’ä½“æ§åˆ¶å’Œç»Ÿè®¡
  const mediaControls = document.getElementById('mediaControls');
  const callStats = document.getElementById('callStats');
  if (hasCall) {
    mediaControls.style.display = 'block';
    callStats.style.display = 'block';
    startCallStatsMonitoring();
  } else {
    mediaControls.style.display = 'none';
    callStats.style.display = 'none';
    stopCallStatsMonitoring();
  }
}

// ====== è®¾å¤‡ç®¡ç† ======

// åˆ·æ–°è®¾å¤‡åˆ—è¡¨
async function refreshDevices() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    availableDevices.cameras = devices.filter(d => d.kind === 'videoinput');
    availableDevices.microphones = devices.filter(d => d.kind === 'audioinput');
    
    updateDeviceSelectors();
    wslog(`è®¾å¤‡åˆ·æ–°: ${availableDevices.cameras.length}ä¸ªæ‘„åƒå¤´, ${availableDevices.microphones.length}ä¸ªéº¦å…‹é£`);
  } catch (e) {
    wslog('è®¾å¤‡æšä¸¾å¤±è´¥: ' + e.message);
  }
}

// æ›´æ–°è®¾å¤‡é€‰æ‹©å™¨
function updateDeviceSelectors() {
  const cameraSelect = document.getElementById('cameraSelect');
  const micSelect = document.getElementById('microphoneSelect');
  
  // æ¸…ç©ºç°æœ‰é€‰é¡¹
  cameraSelect.innerHTML = '<option value="">ğŸ“¹ é€‰æ‹©æ‘„åƒå¤´</option>';
  micSelect.innerHTML = '<option value="">ğŸ™ï¸ é€‰æ‹©éº¦å…‹é£</option>';
  
  // æ·»åŠ æ‘„åƒå¤´é€‰é¡¹
  availableDevices.cameras.forEach(device => {
    const option = document.createElement('option');
    option.value = device.deviceId;
    option.textContent = device.label || `æ‘„åƒå¤´ ${device.deviceId.slice(0, 8)}`;
    cameraSelect.appendChild(option);
  });
  
  // æ·»åŠ éº¦å…‹é£é€‰é¡¹
  availableDevices.microphones.forEach(device => {
    const option = document.createElement('option');
    option.value = device.deviceId;
    option.textContent = device.label || `éº¦å…‹é£ ${device.deviceId.slice(0, 8)}`;
    micSelect.appendChild(option);
  });
}

// ====== åª’ä½“æ§åˆ¶ ======

// åˆ‡æ¢é™éŸ³
function toggleMute() {
  if (!localStream) return;
  
  const audioTrack = localStream.getAudioTracks()[0];
  if (audioTrack) {
    isAudioMuted = !isAudioMuted;
    audioTrack.enabled = !isAudioMuted;
    
    const btn = document.getElementById('muteBtn');
    const localBtn = document.getElementById('localMuteBtn');
    
    if (isAudioMuted) {
      btn.textContent = 'ğŸ”‡ å–æ¶ˆé™éŸ³';
      btn.classList.add('active');
      localBtn.classList.add('active');
    } else {
      btn.textContent = 'ğŸ™ï¸ é™éŸ³';
      btn.classList.remove('active');
      localBtn.classList.remove('active');
    }
    
    wslog(isAudioMuted ? 'å·²é™éŸ³' : 'å·²å–æ¶ˆé™éŸ³');
  }
}

// åˆ‡æ¢è§†é¢‘
function toggleVideo() {
  if (!localStream) return;
  
  const videoTrack = localStream.getVideoTracks()[0];
  if (videoTrack) {
    isVideoMuted = !isVideoMuted;
    videoTrack.enabled = !isVideoMuted;
    
    const btn = document.getElementById('videoBtn');
    const localBtn = document.getElementById('localVideoBtn');
    
    if (isVideoMuted) {
      btn.textContent = 'ğŸ“¹ å¼€å¯è§†é¢‘';
      btn.classList.add('active');
      localBtn.classList.add('active');
    } else {
      btn.textContent = 'ğŸ“¹ å…³é—­è§†é¢‘';
      btn.classList.remove('active');
      localBtn.classList.remove('active');
    }
    
    wslog(isVideoMuted ? 'å·²å…³é—­è§†é¢‘' : 'å·²å¼€å¯è§†é¢‘');
  }
}

// æœ¬åœ°é™éŸ³æ§åˆ¶
function toggleLocalMute() {
  toggleMute();
}

// æœ¬åœ°è§†é¢‘æ§åˆ¶
function toggleLocalVideo() {
  toggleVideo();
}

// å±å¹•å…±äº«
async function shareScreen() {
  try {
    if (isScreenSharing) {
      // åœæ­¢å±å¹•å…±äº«ï¼Œæ¢å¤æ‘„åƒå¤´
      const cameraId = document.getElementById('cameraSelect').value;
      const constraints = {
        video: cameraId ? { deviceId: cameraId } : true,
        audio: { deviceId: document.getElementById('microphoneSelect').value || undefined }
      };
      
      const newStream = await navigator.mediaDevices.getUserMedia(constraints);
      replaceLocalStream(newStream);
      
      document.getElementById('screenBtn').textContent = 'ğŸ–¥ï¸ å…±äº«å±å¹•';
      isScreenSharing = false;
      wslog('å·²åœæ­¢å±å¹•å…±äº«');
    } else {
      // å¼€å§‹å±å¹•å…±äº«
      const screenStream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: true
      });
      
      replaceLocalStream(screenStream);
      
      document.getElementById('screenBtn').textContent = 'ğŸ“¹ æ‘„åƒå¤´';
      isScreenSharing = true;
      wslog('å·²å¼€å§‹å±å¹•å…±äº«');
      
      // ç›‘å¬ç”¨æˆ·åœæ­¢å…±äº«
      screenStream.getVideoTracks()[0].onended = () => {
        shareScreen(); // è‡ªåŠ¨åˆ‡å›æ‘„åƒå¤´
      };
    }
  } catch (e) {
    wslog('å±å¹•å…±äº«å¤±è´¥: ' + e.message);
  }
}

// æ›¿æ¢æœ¬åœ°æµ
function replaceLocalStream(newStream) {
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
  }
  
  localStream = newStream;
  const localVideo = document.getElementById('localVideo');
  if (localVideo) localVideo.srcObject = newStream;
  
  // å¦‚æœåœ¨é€šè¯ä¸­ï¼Œæ›´æ–°PeerConnection
  if (peerConnection && currentCall) {
    const sender = peerConnection.getSenders().find(s => 
      s.track && s.track.kind === 'video'
    );
    if (sender) {
      sender.replaceTrack(newStream.getVideoTracks()[0]);
    }
  }
}

// è®¾å¤‡æµ‹è¯•
async function testDevices() {
  try {
    const cameraId = document.getElementById('cameraSelect').value;
    const micId = document.getElementById('microphoneSelect').value;
    
    const constraints = {
      video: cameraId ? { deviceId: cameraId } : true,
      audio: micId ? { deviceId: micId } : true
    };
    
    const testStream = await navigator.mediaDevices.getUserMedia(constraints);
    const localVideo = document.getElementById('localVideo');
    
    if (localVideo) {
      localVideo.srcObject = testStream;
      wslog('è®¾å¤‡æµ‹è¯•æˆåŠŸ');
      
      // 5ç§’ååœæ­¢æµ‹è¯•
      setTimeout(() => {
        testStream.getTracks().forEach(track => track.stop());
        localVideo.srcObject = null;
        wslog('è®¾å¤‡æµ‹è¯•ç»“æŸ');
      }, 5000);
    }
  } catch (e) {
    wslog('è®¾å¤‡æµ‹è¯•å¤±è´¥: ' + e.message);
  }
}

// å…¨å±åˆ‡æ¢
function toggleFullscreen(videoId) {
  const video = document.getElementById(videoId);
  if (!video) return;
  
  if (document.fullscreenElement) {
    document.exitFullscreen();
  } else {
    video.requestFullscreen().catch(e => {
      wslog('å…¨å±å¤±è´¥: ' + e.message);
    });
  }
}

// ====== é€šè¯ç»Ÿè®¡ ======

// å¼€å§‹é€šè¯ç»Ÿè®¡ç›‘æ§
function startCallStatsMonitoring() {
  if (callStatsInterval) return;
  
  callStatsInterval = setInterval(async () => {
    if (!peerConnection) return;
    
    try {
      const stats = await peerConnection.getStats();
      updateCallStats(stats);
    } catch (e) {
      console.error('è·å–ç»Ÿè®¡å¤±è´¥:', e);
    }
  }, 2000);
}

// åœæ­¢é€šè¯ç»Ÿè®¡ç›‘æ§
function stopCallStatsMonitoring() {
  if (callStatsInterval) {
    clearInterval(callStatsInterval);
    callStatsInterval = null;
  }
  
  // æ¸…ç©ºç»Ÿè®¡æ˜¾ç¤º
  document.getElementById('audioBitrate').textContent = '- kbps';
  document.getElementById('videoBitrate').textContent = '- kbps';
  document.getElementById('packetLoss').textContent = '- %';
  document.getElementById('latency').textContent = '- ms';
}

// æ›´æ–°é€šè¯ç»Ÿè®¡æ˜¾ç¤º
function updateCallStats(stats) {
  let audioBitrate = 0, videoBitrate = 0, packetLoss = 0, latency = 0;
  
  stats.forEach(report => {
    if (report.type === 'outbound-rtp') {
      if (report.kind === 'audio' && report.bytesSent) {
        audioBitrate = Math.round((report.bytesSent * 8) / 1000); // kbps
      } else if (report.kind === 'video' && report.bytesSent) {
        videoBitrate = Math.round((report.bytesSent * 8) / 1000); // kbps
      }
    } else if (report.type === 'inbound-rtp') {
      if (report.packetsLost && report.packetsReceived) {
        packetLoss = Math.round((report.packetsLost / (report.packetsLost + report.packetsReceived)) * 100);
      }
    } else if (report.type === 'candidate-pair' && report.state === 'succeeded') {
      if (report.currentRoundTripTime) {
        latency = Math.round(report.currentRoundTripTime * 1000); // ms
      }
    }
  });
  
  document.getElementById('audioBitrate').textContent = audioBitrate + ' kbps';
  document.getElementById('videoBitrate').textContent = videoBitrate + ' kbps';
  document.getElementById('packetLoss').textContent = packetLoss + ' %';
  document.getElementById('latency').textContent = latency + ' ms';
  
  // æ›´æ–°è¿æ¥çŠ¶æ€
  document.getElementById('connectionState').value = peerConnection.connectionState || '-';
  
  // ç®€å•çš„ç½‘ç»œè´¨é‡è¯„ä¼°
  let quality = 'ä¼˜ç§€';
  if (latency > 200 || packetLoss > 5) quality = 'è¾ƒå·®';
  else if (latency > 100 || packetLoss > 2) quality = 'ä¸€èˆ¬';
  else if (latency > 50 || packetLoss > 1) quality = 'è‰¯å¥½';
  
  document.getElementById('networkQuality').value = quality;
}

function val(id){ return document.getElementById(id).value }
function setVal(id,v){ document.getElementById(id).value=v }
function enableSend(on){ 
  document.getElementById('sendBtn').disabled=!on; 
  document.getElementById('startStreamBtn').disabled=!on; 
  document.getElementById('startCallBtn').disabled=!on || !!currentCall;
  document.getElementById('sendMessageBtn').disabled=!on;
  document.getElementById('mentionBtn').disabled=!on;
  document.getElementById('wsBtn').textContent= on? 'ğŸ”„ é‡è¿' : 'ğŸ”Œ è¿æ¥';
  if (on) initWebRTC();
}

async function sendMention(){
  const convId = val('convId'); const convType = 'group'; const groupId = val('groupId');
  if (!groupId || !convId) { wslog('ERROR: è¯·å…ˆå¡«å†™ groupId/convId'); return; }
  const mentions = val('mentionUsers').split(',').map(s=>s.trim()).filter(Boolean);
  const payload = { text: val('msgText'), mentions };
  const msg = { action: 'send', data: { convId, convType, groupId, type: 'text', clientMsgId: Date.now().toString(), payload } };
  ws.send(JSON.stringify(msg)); wslog('â†’ @ç¾¤æ¶ˆæ¯: ' + JSON.stringify(msg));
}

// æ¶ˆæ¯ç±»å‹åˆ‡æ¢
document.getElementById('messageType').addEventListener('change', function() {
  const type = this.value;
  document.getElementById('textMessage').style.display = type === 'text' ? 'block' : 'none';
  document.getElementById('fileMessage').style.display = ['image', 'voice', 'video', 'file'].includes(type) ? 'block' : 'none';
  document.getElementById('cardMessage').style.display = type === 'card' ? 'block' : 'none';
  document.getElementById('locationMessage').style.display = type === 'location' ? 'block' : 'none';
});

// å‘é€å¤šåª’ä½“æ¶ˆæ¯
async function sendMessage() {
  const type = val('messageType');
  const convId = val('convId'); const convType = val('convType'); const to = val('sendTo'); const groupId = val('sendGroupId');
  
  if (!convId) { wslog('ERROR: è¯·å¡«å†™ä¼šè¯ID'); return; }
  
  let payload = {};
  
  switch (type) {
    case 'text':
      payload = { text: val('msgText') };
      break;
    case 'card':
      payload = { userId: val('cardUserId'), nickname: val('cardNickname'), avatar: val('cardAvatar') };
      break;
    case 'location':
      payload = { latitude: parseFloat(val('locLatitude')), longitude: parseFloat(val('locLongitude')), address: val('locAddress') };
      break;
    case 'image':
    case 'voice':
    case 'video':
    case 'file':
      // éœ€è¦å…ˆä¸Šä¼ æ–‡ä»¶
      wslog('è¯·å…ˆä¸Šä¼ æ–‡ä»¶ï¼Œç„¶åä½¿ç”¨è¿”å›çš„URLæ„é€ æ¶ˆæ¯');
      return;
  }
  
  const msg = { action: 'send', data: { convId, convType, to, groupId, type, clientMsgId: Date.now().toString(), payload } };
  ws.send(JSON.stringify(msg)); wslog('â†’ å‘é€æ¶ˆæ¯: ' + JSON.stringify(msg));
}

// Typingï¼šè¾“å…¥è”åŠ¨ä¸ŠæŠ¥
yetTypingTimer = null;
let typingState = false;
const msgInput = document.getElementById('msgText');
if (msgInput) {
  msgInput.addEventListener('input', () => {
    // è§¦å‘å¼€å§‹è¾“å…¥
    if (!typingState) {
      typingState = true;
      sendTyping(true);
    }
    // åœæ­¢è¾“å…¥ï¼ˆ500ms æ— è¾“å…¥ï¼‰
    clearTimeout(yetTypingTimer);
    yetTypingTimer = setTimeout(() => { typingState = false; sendTyping(false); }, 500);
  });
}

function sendTyping(isTyping) {
  if (!ws || ws.readyState !== 1) return;
  const convId = val('convId'); if (!convId) return;
  const payload = {
    convId: convId,
    convType: val('convType'),
    to: val('sendTo'),
    groupId: val('sendGroupId'),
    typing: !!isTyping,
  };
  const msg = { action: 'typing', data: payload };
  ws.send(JSON.stringify(msg));
}

// æ˜¾ç¤ºå¯¹ç«¯è¾“å…¥ä¸­
defaultTypingHideTimer = null;
function handleTypingIndicator(data) {
  const convId = val('convId');
  if (!convId || data.convId !== convId) return;
  const el = document.getElementById('peerTyping');
  if (!el) return;
  if (data.typing) {
    el.style.display = 'inline-block';
    clearTimeout(defaultTypingHideTimer);
    defaultTypingHideTimer = setTimeout(() => { el.style.display = 'none'; }, 1500);
  } else {
    el.style.display = 'none';
  }
}

// ä¸Šä¼ æ–‡ä»¶
async function uploadFile() {
  const fileInput = document.getElementById('fileInput');
  const file = fileInput.files[0];
  if (!file) { wslog('ERROR: è¯·é€‰æ‹©æ–‡ä»¶'); return; }
  
  const formData = new FormData(); formData.append('file', file);
  
  try {
    const resp = await fetch('/api/files/upload', { method: 'POST', headers: { 'Authorization': 'Bearer ' + val('token') }, body: formData });
    const result = await resp.json();
    if (resp.ok) {
      wslog('âœ“ æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: ' + result.url);
      
      // è‡ªåŠ¨æ„é€ æ¶ˆæ¯è½½è·
      const type = val('messageType');
      let payload = { url: result.url, name: result.fileName, size: result.fileSize, mimeType: result.mimeType };
      
      if (type === 'image') {
        // å¯ä»¥æ·»åŠ å›¾ç‰‡å°ºå¯¸ç­‰ä¿¡æ¯
        payload.format = result.fileName.split('.').pop().toLowerCase();
      } else if (type === 'voice') {
        payload.duration = 0; // éœ€è¦å‰ç«¯æ£€æµ‹éŸ³é¢‘æ—¶é•¿
        payload.format = result.fileName.split('.').pop().toLowerCase();
      } else if (type === 'video') {
        payload.duration = 0; // éœ€è¦å‰ç«¯æ£€æµ‹è§†é¢‘æ—¶é•¿
        payload.format = result.fileName.split('.').pop().toLowerCase();
      }
      
      // æ˜¾ç¤ºè½½è·ä¾›ç”¨æˆ·æŸ¥çœ‹/ä¿®æ”¹
      setVal('msgText', JSON.stringify(payload));
    } else {
      wslog('ERROR: ä¸Šä¼ å¤±è´¥: ' + result.error);
    }
  } catch (e) {
    wslog('ERROR: ä¸Šä¼ å¼‚å¸¸: ' + e.message);
  }
}

// æ–‡ä»¶ç®¡ç†
async function listFiles() {
  try {
    const resp = await get('/api/files');
    const fileList = document.getElementById('fileList');
    fileList.innerHTML = '';
    
    if (resp.files && resp.files.length > 0) {
    resp.files.forEach(file => {
      const div = document.createElement('div');
        div.className = 'file-item';
      div.innerHTML = `
          <div>
            <strong>${file.fileName}</strong><br>
            <small>${(file.fileSize/1024).toFixed(1)}KB - ${file.url}</small>
          </div>
          <button class="btn btn-small btn-danger" onclick="deleteFile('${file.id}')">ğŸ—‘ï¸</button>
      `;
      fileList.appendChild(div);
    });
    } else {
      fileList.innerHTML = '<div style="text-align:center;color:var(--text-muted);padding:20px;">æš‚æ— æ–‡ä»¶</div>';
    }
  } catch (e) { wslog('ERROR: è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥: ' + e.message); }
}

async function deleteFile(fileId) {
  try {
    await fetch(`/api/files/${fileId}`, { method: 'DELETE', headers: { 'Authorization': 'Bearer ' + val('token') } });
    wslog('âœ“ æ–‡ä»¶åˆ é™¤æˆåŠŸ'); listFiles();
  } catch (e) { wslog('ERROR: åˆ é™¤æ–‡ä»¶å¤±è´¥: ' + e.message); }
}

function clearFileList() { document.getElementById('fileList').innerHTML = ''; }

// æ”¶è—ç®¡ç†
async function favoriteCustom() {
  const title = val('favoriteTitle'); const tags = val('favoriteTags').split(',').map(s => s.trim()).filter(s => s);
  const convId = val('convId'); const content = { text: val('msgText'), timestamp: new Date().toISOString() };
  
  if (!title || !convId) { wslog('ERROR: è¯·å¡«å†™æ”¶è—æ ‡é¢˜å’Œä¼šè¯ID'); return; }
  
  try {
    const resp = await post('/api/favorites/custom', { convId, title, content, tags });
    wslog('âœ“ æ”¶è—æˆåŠŸ: ' + resp.id);
  } catch (e) { wslog('ERROR: æ”¶è—å¤±è´¥: ' + e.message); }
}

async function listFavorites() {
  try {
    const resp = await get('/api/favorites');
    const favoriteList = document.getElementById('favoriteList');
    favoriteList.innerHTML = '';
    
    if (resp.favorites && resp.favorites.length > 0) {
    resp.favorites.forEach(fav => {
      const div = document.createElement('div');
        div.className = 'favorite-item';
      div.innerHTML = `
          <div>
            <strong>${fav.title}</strong> [${fav.type}]<br>
            <small>æ ‡ç­¾: ${fav.tags || 'æ— '}</small>
          </div>
          <button class="btn btn-small btn-danger" onclick="deleteFavorite('${fav.id}')">ğŸ—‘ï¸</button>
      `;
      favoriteList.appendChild(div);
    });
    } else {
      favoriteList.innerHTML = '<div style="text-align:center;color:var(--text-muted);padding:20px;">æš‚æ— æ”¶è—</div>';
    }
  } catch (e) { wslog('ERROR: è·å–æ”¶è—å¤±è´¥: ' + e.message); }
}

async function searchFavorites() {
  const keyword = val('favoriteSearch');
  if (!keyword) { wslog('ERROR: è¯·è¾“å…¥æœç´¢å…³é”®è¯'); return; }
  
  try {
    const resp = await get(`/api/favorites/search?keyword=${encodeURIComponent(keyword)}`);
    const favoriteList = document.getElementById('favoriteList');
    favoriteList.innerHTML = `<div style="font-weight:600;margin-bottom:12px;">æœç´¢ç»“æœ (${resp.favorites?.length || 0})</div>`;
    
    if (resp.favorites && resp.favorites.length > 0) {
    resp.favorites.forEach(fav => {
      const div = document.createElement('div');
        div.className = 'favorite-item';
        div.innerHTML = `
          <div>
            <strong>${fav.title}</strong> [${fav.type}]<br>
            <small>æ ‡ç­¾: ${fav.tags || 'æ— '}</small>
          </div>
        `;
      favoriteList.appendChild(div);
    });
    } else {
      favoriteList.innerHTML += '<div style="text-align:center;color:var(--text-muted);padding:20px;">æœªæ‰¾åˆ°ç›¸å…³æ”¶è—</div>';
    }
  } catch (e) { wslog('ERROR: æœç´¢æ”¶è—å¤±è´¥: ' + e.message); }
}

async function deleteFavorite(favoriteId) {
  try {
    await fetch(`/api/favorites/${favoriteId}`, { method: 'DELETE', headers: { 'Authorization': 'Bearer ' + val('token') } });
    wslog('âœ“ æ”¶è—åˆ é™¤æˆåŠŸ'); listFavorites();
  } catch (e) { wslog('ERROR: åˆ é™¤æ”¶è—å¤±è´¥: ' + e.message); }
}

async function favoriteStats() {
  try {
    const stats = await get('/api/favorites/stats');
    wslog('ğŸ“Š æ”¶è—ç»Ÿè®¡: ' + JSON.stringify(stats));
  } catch (e) { wslog('ERROR: è·å–æ”¶è—ç»Ÿè®¡å¤±è´¥: ' + e.message); }
}

// å¤„ç†æåŠæ¶ˆæ¯
function handleMention(data) {
  const convId = val('convId');
  if (!convId || data.convId !== convId) return;
  const mentionUsers = val('mentionUsers').split(',').map(s => s.trim()).filter(s => s);
  const mentionText = val('msgText');
  const mentionRegex = new RegExp('@(' + mentionUsers.join('|') + ')', 'g');
  const newText = mentionText.replace(mentionRegex, (match) => {
    const userId = match.substring(1); // ç§»é™¤ @ ç¬¦å·
    return `<span style="color: #57606a; font-weight: bold;">@${userId}</span>`;
  });
  setVal('msgText', newText);
  document.getElementById('mentionBtn').disabled = mentionUsers.length === 0;
}

// å¤„ç†ç¾¤å…¬å‘Š
async function createNotice() {
  const groupId = val('noticeGroupId');
  const title = val('noticeTitle');
  const content = val('noticeContent');

  if (!groupId || !title || !content) {
    wslog('ERROR: è¯·å¡«å†™ç¾¤IDã€æ ‡é¢˜å’Œå†…å®¹');
    return;
  }

  try {
    const resp = await post(`/api/groups/${groupId}/notices`, { title, content });
    wslog('âœ“ å…¬å‘Šå‘å¸ƒæˆåŠŸ: ' + resp.id);
    listNotices(); // åˆ·æ–°å…¬å‘Šåˆ—è¡¨
  } catch (e) { wslog('ERROR: å‘å¸ƒå…¬å‘Šå¤±è´¥: ' + e.message); }
}

async function listNotices() {
  const groupId = val('noticeGroupId');
  if (!groupId) {
    wslog('ERROR: è¯·å…ˆé€‰æ‹©ç¾¤ID');
    return;
  }

  try {
    const resp = await get(`/api/groups/${groupId}/notices`);
    const noticeList = document.getElementById('noticeList');
    noticeList.innerHTML = `<div style="font-weight:600;margin-bottom:12px;">ç¾¤å…¬å‘Š (${resp.list?.length || 0})</div>`;
    
    if (resp.list && resp.list.length > 0) {
    resp.list.forEach(notice => {
        const div = document.createElement('div');
        div.className = 'notice-item';
        div.innerHTML = `
          <div>
            <strong>${notice.title}</strong><br>
            <small>${notice.content}</small>
          </div>
        `;
        noticeList.appendChild(div);
      });
    } else {
      noticeList.innerHTML += '<div style="text-align:center;color:var(--text-muted);padding:20px;">æš‚æ— å…¬å‘Š</div>';
    }
  } catch (e) { wslog('ERROR: è·å–å…¬å‘Šå¤±è´¥: ' + e.message); }
}

async function setGroupMute() {
  const groupId = val('muteGroupId');
  const muted = val('muteOn') === 'true';

  if (!groupId) {
    wslog('ERROR: è¯·å…ˆé€‰æ‹©ç¾¤ID');
    return;
  }

  try {
    await post(`/api/groups/${groupId}/mute`, { muted });
    wslog(`âœ“ ç¾¤ ${groupId} å…¨å‘˜ç¦è¨€ ${muted ? 'å¼€å¯' : 'å…³é—­'}`);
  } catch (e) { wslog('ERROR: è®¾ç½®ç¾¤ç¦è¨€å¤±è´¥: ' + e.message); }
}

// OSS ç›´ä¼ 
async function ossDirectUpload() {
  const fileInput = document.getElementById('ossFile');
  const ossDirInput = document.getElementById('ossDir');
  const ossUploadURLInput = document.getElementById('ossUploadURL');

  if (!fileInput.files[0]) { wslog('ERROR: è¯·é€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶'); return; }
  const file = fileInput.files[0];
  const userDir = (ossDirInput.value || '').replace(/^\/+|\/+$/g, '');

  try {
    // 1) å‘åç«¯ç”³è¯· policyï¼ˆPOST è¡¨å•ï¼šdir å¯é€‰ï¼‰
    const policyForm = new FormData();
    if (userDir) policyForm.append('dir', userDir);
    const policyResp = await fetch('/api/files/oss/policy', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + val('token') },
      body: policyForm
    });
    const p = await policyResp.json();
    if (!policyResp.ok) { wslog('ERROR: è·å– OSS policy å¤±è´¥: ' + (p.error || '')); return; }

    const host = p.host;            // https://bucket.endpoint
    const keyPrefix = p.dir;        // åç«¯è¿”å›çš„å‰ç¼€ï¼Œå·²åŒ…å«æ—¥æœŸï¼Œå¦‚ uploads/2025/08/08/
    const accessKeyId = p.accessKeyId;
    const policy = p.policy;
    const signature = p.signature;

    // 2) ç”Ÿæˆ object keyï¼ˆå‰ç¼€ + éšæœºåï¼‰
    const ext = (file.name.lastIndexOf('.') >= 0) ? file.name.substring(file.name.lastIndexOf('.')) : '';
    const rand = (Date.now().toString(36) + Math.random().toString(36).slice(2,8)).toLowerCase();
    const objectKey = keyPrefix + rand + ext;

    // 3) æ„é€ ç›´ä¼ è¡¨å•å¹¶ä¸Šä¼ åˆ° OSS
    const formData = new FormData();
    formData.append('key', objectKey);
    formData.append('policy', policy);
    formData.append('OSSAccessKeyId', accessKeyId);
    formData.append('success_action_status', '200');
    formData.append('signature', signature);
    formData.append('file', file);

    const uploadResp = await fetch(host, { method: 'POST', body: formData });
    if (uploadResp.status !== 200) {
      const errText = await uploadResp.text();
      wslog('ERROR: OSS ç›´ä¼ å¤±è´¥: ' + uploadResp.status + ' ' + errText);
      return;
    }

    const fileURL = host.replace(/\/$/, '') + '/' + objectKey;
    ossUploadURLInput.value = fileURL;
    wslog('âœ“ OSS ç›´ä¼ æˆåŠŸ: ' + fileURL);

    // 4) é€šçŸ¥åç«¯å…¥åº“ï¼ˆå¯é€‰ï¼‰
    const confirmResp = await post('/api/files/oss/confirm', { key: objectKey, size: file.size, mimeType: file.type });
    if (confirmResp && confirmResp.id) {
      wslog('âœ“ åç«¯å·²å…¥åº“: ' + confirmResp.id);
    }

    // 5) å°†æ–‡ä»¶æ¶ˆæ¯è½½è·å†™å…¥æ–‡æœ¬æ¡†ï¼Œä¾¿äºç›´æ¥å‘é€
    const type = val('messageType');
    let payload = { url: fileURL, name: file.name, size: file.size, mimeType: file.type };
    setVal('msgText', JSON.stringify(payload));
  } catch (e) {
    wslog('ERROR: OSS ç›´ä¼ å¼‚å¸¸: ' + e.message);
  }
}

// å•èŠ / ç¾¤èŠ ä¼šè¯ç”Ÿæˆ
function generateConvId() {
  const convType = document.getElementById('convType').value;
  const to = document.getElementById('sendTo').value;
  const groupId = document.getElementById('sendGroupId').value;
  const convIdInput = document.getElementById('convId');

  if (convType === 'c2c') {
    if (!to) { wslog('ERROR: è¯·å…ˆå¡«å†™å¯¹æ–¹ç”¨æˆ·ID'); return; }
    convIdInput.value = `c2c-${to}-${Date.now()}`;
  } else if (convType === 'group') {
    if (!groupId) { wslog('ERROR: è¯·å…ˆå¡«å†™ç¾¤ID'); return; }
    convIdInput.value = `group-${groupId}-${Date.now()}`;
  }
  wslog('âœ“ ä¼šè¯IDç”ŸæˆæˆåŠŸ: ' + convIdInput.value);
}

function subscribeGroup() {
  const groupId = val('sendGroupId') || val('groupId');
  if (!groupId) { wslog('ERROR: è¯·å…ˆå¡«å†™ç¾¤ID'); return; }
  if (!ws || ws.readyState !== 1) { wslog('ERROR: WS æœªè¿æ¥'); return; }
  const msg = { action: 'subscribe_group', data: { groupId } };
  ws.send(JSON.stringify(msg));
  wslog('â†’ è®¢é˜…ç¾¤: ' + groupId);
}

function wsSendText(){ 
  if(!ws||ws.readyState!==1){ wslog('ERROR: WS æœªè¿æ¥'); return } 
  const t=val('payloadText'); 
  const convType=val('convType'); 
  const d={ 
    convId: val('convId')||'conv-demo', 
    convType, 
    clientMsgId: val('clientMsgId')||('cmid-'+Date.now()), 
    type:'text', 
    payload:{text:t} 
  }; 
  if(convType==='c2c') d.to=val('sendTo'); 
  else d.groupId=val('sendGroupId'); 
  const msg={action:'send', data:d}; 
  ws.send(JSON.stringify(msg)); 
  wslog('â†’ '+JSON.stringify(msg)); 
}

function startStream(){ 
  if(!ws||ws.readyState!==1){ wslog('ERROR: WS æœªè¿æ¥'); return } 
  const t=val('streamText'); 
  const convType=val('convType'); 
  const d={ 
    convId: val('convId')||'conv-demo', 
    convType, 
    clientMsgId: 'stream-'+Date.now(), 
    type:'stream', 
    payload:{text:t} 
  }; 
  if(convType==='c2c') d.to=val('sendTo'); 
  else d.groupId=val('sendGroupId'); 
  const msg={action:'start_stream', data:d}; 
  ws.send(JSON.stringify(msg)); 
  wslog('â†’ å¼€å§‹æµå¼: '+JSON.stringify(msg)); 
}

function sendChunk(){ 
  if(!ws||ws.readyState!==1){ wslog('ERROR: WS æœªè¿æ¥'); return } 
  const streamId=val('currentStreamId'); 
  if(!streamId){ wslog('ERROR: æ— æµ ID'); return; } 
  const delta=val('streamDelta'); 
  const msg={action:'stream_chunk', data:{streamId, delta}}; 
  ws.send(JSON.stringify(msg)); 
  wslog('â†’ æµç‰‡æ®µ: '+JSON.stringify(msg)); 
}

function endStream(){ 
  if(!ws||ws.readyState!==1){ wslog('ERROR: WS æœªè¿æ¥'); return } 
  const streamId=val('currentStreamId'); 
  if(!streamId){ wslog('ERROR: æ— æµ ID'); return; } 
  const finalText=val('streamText')+' [å®Œæˆ]'; 
  const msg={action:'end_stream', data:{streamId, finalText}}; 
  ws.send(JSON.stringify(msg)); 
  wslog('â†’ ç»“æŸæµå¼: '+JSON.stringify(msg)); 
  setVal('currentStreamId', ''); 
  enableStreamBtns(false); 
}

// WebSocket æ¶ˆæ¯å¤„ç†
function handleWSMessage(data) {
  try {
    const msg = JSON.parse(data);
    
    switch (msg.action) {
      case 'typing':
        handleTypingIndicator(msg.data);
        break;
      case 'mention':
        handleMention(msg.data);
        break;
      case 'call_incoming':
        currentCall = msg.data;
        setVal('currentCallId', currentCall.id);
        setVal('callStatus', 'æ¥ç”µ');
        updateCallButtons();
        wslog('ğŸ“ æ”¶åˆ°æ¥ç”µ: ' + currentCall.fromUserId);
        // è¢«å«å…ˆå‡†å¤‡æœ¬åœ°æµï¼ˆåœ¨ç‚¹å‡»æ¥å¬æ—¶ä¹Ÿä¼šå†æ¬¡è·å–ï¼‰
        break;
      case 'call_started':
        currentCall = msg.data;
        setVal('currentCallId', currentCall.id);
        setVal('callStatus', 'é€šè¯ä¸­');
        updateCallButtons();
        break;
      case 'call_answered':
        if (currentCall) {
          currentCall.status = 'connected';
          setVal('callStatus', 'å·²æ¥é€š');
          updateCallButtons();
          // ä¸»å«æ–¹åœ¨å¯¹æ–¹æ¥å¬ååˆ›å»ºOffer
          if (currentCall.fromUserId === val('userId')) {
            createPeerConnection();
            if (localStream) {
              localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
            }
            (async ()=>{
              try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                const msg = { action: 'webrtc_signaling', data: { callId: currentCall.id, type: 'offer', sdp: offer.sdp, to: getOtherUserId() } };
                ws.send(JSON.stringify(msg));
                wslog('â†’ å‘é€Offer');
              } catch(e) { wslog('åˆ›å»º/å‘é€Offerå¤±è´¥: '+e.message); }
            })();
          }
        }
        break;
      case 'call_rejected':
        cleanupCall();
        wslog('âŒ é€šè¯è¢«æ‹’æ¥');
        break;
      case 'call_ended':
        cleanupCall();
        wslog('ğŸ“µ é€šè¯å·²ç»“æŸ');
        break;
      case 'webrtc_signaling':
        handleSignalingMessage(msg.data);
        break;
      case 'stream_started':
        if (msg.data && msg.data.streamId) {
          setVal('currentStreamId', msg.data.streamId);
          enableStreamBtns(true);
        }
        break;
      case 'stream_ended':
        setVal('currentStreamId', '');
        enableStreamBtns(false);
        break;
    }
  } catch (e) {
    console.error('å¤„ç† WS æ¶ˆæ¯å¤±è´¥:', e);
  }
}

// åˆå§‹åŒ–è¿æ¥çŠ¶æ€
updateConnectionStatus(false);

// åˆå§‹åŒ–è®¾å¤‡åˆ—è¡¨
document.addEventListener('DOMContentLoaded', () => {
  refreshDevices();
});
</script>
</body>
</html> 