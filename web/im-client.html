
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GO-IM èŠå¤©å®¢æˆ·ç«¯</title>
  <meta name="description" content="ç°ä»£åŒ–å³æ—¶é€šè®¯å®¢æˆ·ç«¯ï¼Œæ”¯æŒæ–‡å­—ã€å›¾ç‰‡ã€æ–‡ä»¶ä¼ è¾“å’ŒéŸ³è§†é¢‘é€šè¯">
  <meta name="theme-color" content="#007AFF">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="GO-IM">
  <link rel="manifest" href="/manifest.json">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #007AFF;
      --primary-dark: #0056CC;
      --success: #34C759;
      --danger: #FF3B30;
      --warning: #FF9500;
      --info: #5AC8FA;
      
      /* æ·±è‰²ä¸»é¢˜ */
      --bg-primary: #000000;
      --bg-secondary: #1C1C1E;
      --bg-tertiary: #2C2C2E;
      --bg-quaternary: #3A3A3C;
      
      /* æµ…è‰²è¦†ç›–å±‚ */
      --bg-overlay: rgba(255, 255, 255, 0.1);
      --bg-hover: rgba(255, 255, 255, 0.05);
      
      /* æ–‡æœ¬é¢œè‰² */
      --text-primary: #FFFFFF;
      --text-secondary: #EBEBF5;
      --text-tertiary: #EBEBF5;
      --text-quaternary: #8E8E93;
      
      /* è¾¹æ¡†å’Œåˆ†å‰²çº¿ */
      --border: rgba(84, 84, 88, 0.6);
      --separator: rgba(84, 84, 88, 0.4);
      
      /* é˜´å½± */
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.4);
      
      /* æ¶ˆæ¯æ°”æ³¡ */
      --msg-sent: var(--primary);
      --msg-received: var(--bg-tertiary);
      --msg-system: var(--bg-quaternary);
      
      /* åŠ¨ç”» */
      --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* æµ…è‰²ä¸»é¢˜ */
    @media (prefers-color-scheme: light) {
      :root {
        --bg-primary: #FFFFFF;
        --bg-secondary: #F2F2F7;
        --bg-tertiary: #FFFFFF;
        --bg-quaternary: #F2F2F7;
        
        --bg-overlay: rgba(0, 0, 0, 0.05);
        --bg-hover: rgba(0, 0, 0, 0.03);
        
        --text-primary: #000000;
        --text-secondary: #3C3C43;
        --text-tertiary: #3C3C43;
        --text-quaternary: #8E8E93;
        
        --border: rgba(60, 60, 67, 0.3);
        --separator: rgba(60, 60, 67, 0.2);
        
        --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
        --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
        
        --msg-received: #E5E5EA;
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.5;
      overflow: hidden;
      height: 100vh;
    }

    /* ä¸»å¸ƒå±€ */
    .app-container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    /* å·¦ä¾§è¾¹æ  */
    .sidebar {
      width: 300px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      position: relative;
      z-index: 10;
    }

    /* ä¸»èŠå¤©åŒºåŸŸ */
    .main-chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--bg-primary);
      position: relative;
    }

    /* å³ä¾§ä¿¡æ¯é¢æ¿ */
    .info-panel {
      width: 280px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transform: translateX(100%);
      transition: var(--transition);
    }

    .info-panel.open {
      transform: translateX(0);
    }

    /* ===== ä¾§è¾¹æ ç»„ä»¶ ===== */

    /* ç”¨æˆ·å¤´éƒ¨ */
    .user-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 16px;
    }

    .user-info {
      flex: 1;
    }

    .user-name {
      font-weight: 600;
      font-size: 16px;
      color: var(--text-primary);
    }

    .user-status {
      font-size: 13px;
      color: var(--text-quaternary);
    }

    .user-actions {
      display: flex;
      gap: 8px;
    }

    .icon-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: var(--bg-overlay);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
      color: var(--text-secondary);
    }

    .icon-btn:hover {
      background: var(--bg-hover);
      transform: scale(1.05);
    }

    /* æœç´¢æ  */
    .search-bar {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
    }

    .search-input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 14px;
      color: var(--text-primary);
      transition: var(--transition);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
    }

    .search-input::placeholder {
      color: var(--text-quaternary);
    }

    /* æ ‡ç­¾é¡µ */
    .tab-bar {
      display: flex;
      border-bottom: 1px solid var(--border);
    }

    .tab-item {
      flex: 1;
      padding: 12px;
      text-align: center;
      background: none;
      border: none;
      color: var(--text-quaternary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      position: relative;
    }

    .tab-item.active {
      color: var(--primary);
    }

    .tab-item.active::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--primary);
    }

    /* ä¼šè¯åˆ—è¡¨ */
    .conversation-list {
      flex: 1;
      overflow-y: auto;
    }

    .conversation-item {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      gap: 12px;
      cursor: pointer;
      transition: var(--transition);
      border-bottom: 1px solid var(--separator);
      position: relative;
    }

    .conversation-item:hover {
      background: var(--bg-hover);
    }

    .conversation-item.active {
      background: var(--bg-overlay);
    }

    .conversation-item.unread {
      background: rgba(0, 122, 255, 0.05);
    }

    .conversation-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 18px;
      position: relative;
    }

    .conversation-info {
      flex: 1;
      min-width: 0;
    }

    .conversation-name {
      font-weight: 600;
      font-size: 15px;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .conversation-preview {
      font-size: 13px;
      color: var(--text-quaternary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .conversation-meta {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    .conversation-time {
      font-size: 12px;
      color: var(--text-quaternary);
    }

    .unread-badge {
      background: var(--danger);
      color: white;
      border-radius: 10px;
      padding: 2px 6px;
      font-size: 11px;
      font-weight: 600;
      min-width: 18px;
      text-align: center;
    }

    .online-indicator {
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 12px;
      height: 12px;
      background: var(--success);
      border: 2px solid var(--bg-secondary);
      border-radius: 50%;
    }

    /* ===== èŠå¤©åŒºåŸŸ ===== */

    /* èŠå¤©å¤´éƒ¨ */
    .chat-header {
      height: 60px;
      padding: 0 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      background: var(--bg-tertiary);
    }

    .chat-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
    }

    .chat-info {
      flex: 1;
    }

    .chat-name {
      font-weight: 600;
      font-size: 16px;
      color: var(--text-primary);
    }

    .chat-status {
      font-size: 13px;
      color: var(--text-quaternary);
    }

    .chat-actions {
      display: flex;
      gap: 8px;
    }

    /* æ¶ˆæ¯åŒºåŸŸ */
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .message-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .message-group.sent {
      align-items: flex-end;
    }

    .message-group.received {
      align-items: flex-start;
    }

    .message-item {
      max-width: 70%;
      display: flex;
      align-items: flex-end;
      gap: 8px;
    }

    .message-item.sent {
      flex-direction: row-reverse;
    }

    .message-bubble {
      padding: 12px 16px;
      border-radius: 18px;
      font-size: 15px;
      line-height: 1.4;
      word-wrap: break-word;
      position: relative;
    }

    .message-bubble.sent {
      background: var(--msg-sent);
      color: white;
      border-bottom-right-radius: 6px;
    }

    .message-bubble.received {
      background: var(--msg-received);
      color: var(--text-primary);
      border-bottom-left-radius: 6px;
    }

    .message-bubble.system {
      background: var(--msg-system);
      color: var(--text-secondary);
      text-align: center;
      font-size: 13px;
      border-radius: 12px;
      margin: 8px auto;
      max-width: 80%;
    }

    .message-time {
      font-size: 11px;
      color: var(--text-quaternary);
      padding: 0 4px;
    }

    .message-status {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    /* è¾“å…¥åŒºåŸŸ */
    .input-area {
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      background: var(--bg-tertiary);
    }

    .input-container {
      display: flex;
      align-items: flex-end;
      gap: 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 8px;
      min-height: 40px;
    }

    .input-actions {
      display: flex;
      gap: 4px;
    }

    .input-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-quaternary);
      transition: var(--transition);
    }

    .input-btn:hover {
      background: var(--bg-overlay);
      color: var(--text-secondary);
    }

    .message-input {
      flex: 1;
      background: none;
      border: none;
      outline: none;
      color: var(--text-primary);
      font-size: 15px;
      line-height: 1.4;
      resize: none;
      max-height: 120px;
      min-height: 24px;
    }

    .message-input::placeholder {
      color: var(--text-quaternary);
    }

    .send-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: var(--primary);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: white;
      transition: var(--transition);
    }

    .send-btn:hover {
      background: var(--primary-dark);
      transform: scale(1.05);
    }

    .send-btn:disabled {
      background: var(--text-quaternary);
      cursor: not-allowed;
      transform: none;
    }

    /* è¾“å…¥çŠ¶æ€æç¤º */
    .typing-indicator {
      padding: 8px 20px;
      font-size: 13px;
      color: var(--text-quaternary);
      font-style: italic;
    }

    /* ===== å“åº”å¼è®¾è®¡ ===== */

    /* ç§»åŠ¨ç«¯é€‚é… */
    @media (max-width: 768px) {
      .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        height: 100vh;
        transform: translateX(-100%);
        transition: var(--transition);
        z-index: 1000;
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .main-chat {
        width: 100%;
      }

      .info-panel {
        position: fixed;
        right: 0;
        top: 0;
        height: 100vh;
        z-index: 1000;
      }

      .chat-header {
        padding: 0 16px;
      }

      .messages-container {
        padding: 16px;
      }

      .input-area {
        padding: 12px 16px;
      }

      .message-item {
        max-width: 85%;
      }
    }

    /* å¹³æ¿é€‚é… */
    @media (max-width: 1024px) and (min-width: 769px) {
      .sidebar {
        width: 280px;
      }

      .info-panel {
        width: 260px;
      }
    }

    /* è¦†ç›–å±‚ */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: var(--transition);
    }

    .overlay.show {
      opacity: 1;
      pointer-events: all;
    }

    /* ===== ç»„ä»¶æ ·å¼ ===== */

    /* ç™»å½•æ¨¡æ€æ¡† */
    .login-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      backdrop-filter: blur(10px);
    }

    .login-form {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 32px;
      width: 400px;
      max-width: 90vw;
      box-shadow: var(--shadow-lg);
    }

    .login-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .login-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 8px;
      background: linear-gradient(135deg, var(--primary), var(--info));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .login-subtitle {
      color: var(--text-quaternary);
      font-size: 14px;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-input {
      width: 100%;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 16px;
      font-size: 15px;
      color: var(--text-primary);
      transition: var(--transition);
    }

    .form-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
    }

    .form-input::placeholder {
      color: var(--text-quaternary);
    }

    .btn {
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 12px 20px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      width: 100%;
    }

    .btn:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }

    .btn:disabled {
      background: var(--text-quaternary);
      cursor: not-allowed;
      transform: none;
    }

    .btn-secondary {
      background: var(--bg-quaternary);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: var(--bg-hover);
    }

    /* è¿æ¥çŠ¶æ€ */
    .connection-status {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      z-index: 100;
      box-shadow: var(--shadow);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-quaternary);
    }

    .status-dot.connected {
      background: var(--success);
    }

    .status-dot.connecting {
      background: var(--warning);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* ç©ºçŠ¶æ€ */
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px;
    }

    .empty-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .empty-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-secondary);
    }

    .empty-subtitle {
      color: var(--text-quaternary);
      font-size: 14px;
    }

    /* æ»šåŠ¨æ¡æ ·å¼ */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--text-quaternary);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-tertiary);
    }

    /* éšè—ç±» */
    .hidden {
      display: none !important;
    }

    /* åŠ è½½åŠ¨ç”» */
    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--text-quaternary);
      border-radius: 50%;
      border-top: 2px solid var(--primary);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* WebRTC é€šè¯ç•Œé¢ */
    .call-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
    }

    .call-container {
      background: var(--bg-secondary);
      border-radius: 20px;
      padding: 32px;
      width: 90vw;
      max-width: 600px;
      max-height: 80vh;
      box-shadow: var(--shadow-lg);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .call-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .call-title {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .call-status {
      font-size: 16px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .call-duration {
      font-size: 14px;
      color: var(--text-quaternary);
      font-family: 'Monaco', monospace;
    }

    .call-videos {
      display: flex;
      gap: 20px;
      margin-bottom: 32px;
      width: 100%;
      flex-wrap: wrap;
      justify-content: center;
    }

    .call-video {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      background: var(--bg-primary);
      box-shadow: var(--shadow);
    }

    .call-video.main {
      width: 100%;
      max-width: 400px;
      aspect-ratio: 16/9;
    }

    .call-video.pip {
      width: 120px;
      height: 90px;
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 10;
      border: 2px solid var(--bg-secondary);
    }

    .call-video video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .call-video-label {
      position: absolute;
      bottom: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
    }

    .call-controls {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 20px;
    }

    .call-btn {
      width: 56px;
      height: 56px;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
      font-size: 20px;
      color: white;
      box-shadow: var(--shadow);
    }

    .call-btn.mute {
      background: var(--bg-quaternary);
    }

    .call-btn.mute.active {
      background: var(--danger);
    }

    .call-btn.video {
      background: var(--bg-quaternary);
    }

    .call-btn.video.active {
      background: var(--warning);
    }

    .call-btn.screen {
      background: var(--info);
    }

    .call-btn.answer {
      background: var(--success);
      width: 64px;
      height: 64px;
      font-size: 24px;
    }

    .call-btn.decline {
      background: var(--danger);
      width: 64px;
      height: 64px;
      font-size: 24px;
    }

    .call-btn.end {
      background: var(--danger);
      width: 64px;
      height: 64px;
      font-size: 24px;
    }

    .call-btn:hover {
      transform: scale(1.1);
    }

    .call-stats {
      display: flex;
      gap: 20px;
      font-size: 12px;
      color: var(--text-quaternary);
      text-align: center;
    }

    .call-stat {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .call-stat-label {
      font-weight: 500;
    }

    .call-stat-value {
      font-family: 'Monaco', monospace;
    }

    /* æ¶ˆæ¯å¼•ç”¨æ ·å¼ */
    .message-reply {
      background: var(--bg-overlay);
      border-left: 3px solid var(--primary);
      padding: 8px 12px;
      margin-bottom: 8px;
      border-radius: 0 8px 8px 0;
      font-size: 13px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: var(--transition);
    }

    .message-reply:hover {
      background: var(--bg-hover);
    }

    .message-reply-author {
      font-weight: 600;
      color: var(--primary);
      margin-bottom: 2px;
    }

    .message-reply-content {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .message-reply-close {
      float: right;
      background: none;
      border: none;
      color: var(--text-quaternary);
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      margin-left: 8px;
    }

    /* æ¶ˆæ¯æ“ä½œèœå• */
    .message-menu {
      position: absolute;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 0;
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      min-width: 120px;
    }

    .message-menu-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      cursor: pointer;
      transition: var(--transition);
      font-size: 14px;
      color: var(--text-primary);
    }

    .message-menu-item:hover {
      background: var(--bg-hover);
    }

    .message-menu-item.danger {
      color: var(--danger);
    }

    /* @æåŠæ ·å¼ */
    .mention {
      background: rgba(0, 122, 255, 0.1);
      color: var(--primary);
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: 600;
    }

    .mention-picker {
      position: absolute;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 0;
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      min-width: 200px;
      max-height: 200px;
      overflow-y: auto;
    }

    .mention-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 16px;
      cursor: pointer;
      transition: var(--transition);
    }

    .mention-item:hover {
      background: var(--bg-hover);
    }

    .mention-item.selected {
      background: var(--primary);
      color: white;
    }

    .mention-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 12px;
    }

    .mention-info {
      flex: 1;
    }

    .mention-name {
      font-weight: 600;
      font-size: 14px;
    }

    .mention-username {
      font-size: 12px;
      color: var(--text-quaternary);
    }

    /* æ¶ˆæ¯çŠ¶æ€æŒ‡ç¤º */
    .message-recalled {
      opacity: 0.6;
      font-style: italic;
      background: var(--bg-overlay) !important;
    }

    .message-recalled .message-bubble {
      background: transparent !important;
      border: 1px dashed var(--border);
    }

    @media (max-width: 768px) {
      .call-container {
        width: 95vw;
        padding: 24px 16px;
      }

      .call-videos {
        flex-direction: column;
        align-items: center;
      }

      .call-video.pip {
        position: static;
        width: 100px;
        height: 75px;
        margin-top: 16px;
      }

      .call-controls {
        gap: 12px;
      }

      .call-btn {
        width: 48px;
        height: 48px;
        font-size: 18px;
      }

      .call-btn.answer,
      .call-btn.decline,
      .call-btn.end {
        width: 56px;
        height: 56px;
        font-size: 20px;
      }

      .call-stats {
        gap: 16px;
        font-size: 11px;
      }
    }

    /* å·¥å…·æç¤º */
    .tooltip {
      position: relative;
    }

    .tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-quaternary);
      color: var(--text-primary);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: var(--transition);
      margin-bottom: 8px;
    }

    .tooltip:hover::after {
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- è¿æ¥çŠ¶æ€ -->
  <div class="connection-status">
    <div class="status-dot" id="connectionDot"></div>
    <span id="connectionText">æœªè¿æ¥</span>
  </div>

  <!-- ç™»å½•æ¨¡æ€æ¡† -->
  <div class="login-modal" id="loginModal">
    <div class="login-form">
      <div class="login-header">
        <h1 class="login-title">GO-IM</h1>
        <p class="login-subtitle">ç°ä»£åŒ–å³æ—¶é€šè®¯å®¢æˆ·ç«¯</p>
      </div>
      
      <div class="form-group">
        <input type="text" class="form-input" id="serverUrl" placeholder="æœåŠ¡å™¨åœ°å€" value="http://localhost:8080">
      </div>
      
      <div class="form-group">
        <input type="text" class="form-input" id="username" placeholder="ç”¨æˆ·å">
      </div>
      
      <div class="form-group">
        <input type="password" class="form-input" id="password" placeholder="å¯†ç ">
      </div>
      
      <div class="form-group">
        <input type="text" class="form-input" id="nickname" placeholder="æ˜µç§°ï¼ˆæ³¨å†Œæ—¶ä½¿ç”¨ï¼‰">
      </div>
      
      <div class="form-group">
        <button class="btn" id="loginBtn" onclick="login()">ç™»å½•</button>
      </div>
      
      <div class="form-group">
        <button class="btn btn-secondary" id="registerBtn" onclick="register()">æ³¨å†Œ</button>
      </div>
    </div>
  </div>

  <!-- ä¸»åº”ç”¨å®¹å™¨ -->
  <div class="app-container" id="appContainer" style="display: none;">
    <!-- ç§»åŠ¨ç«¯è¦†ç›–å±‚ -->
    <div class="overlay" id="overlay" onclick="closePanels()"></div>

    <!-- å·¦ä¾§è¾¹æ  -->
    <div class="sidebar" id="sidebar">
      <!-- ç”¨æˆ·å¤´éƒ¨ -->
      <div class="user-header">
        <div class="user-avatar" id="userAvatar">U</div>
        <div class="user-info">
          <div class="user-name" id="userName">ç”¨æˆ·</div>
          <div class="user-status" id="userStatus">åœ¨çº¿</div>
        </div>
        <div class="user-actions">
          <button class="icon-btn tooltip" data-tooltip="è®¾ç½®" onclick="openSettings()">âš™ï¸</button>
          <button class="icon-btn tooltip" data-tooltip="é€€å‡º" onclick="logout()">ğŸšª</button>
        </div>
      </div>

      <!-- æœç´¢æ  -->
      <div class="search-bar">
        <input type="text" class="search-input" placeholder="æœç´¢ä¼šè¯ã€è”ç³»äºº..." id="searchInput">
      </div>

      <!-- æ ‡ç­¾é¡µ -->
      <div class="tab-bar">
        <button class="tab-item active" data-tab="chats" onclick="switchTab('chats')">èŠå¤©</button>
        <button class="tab-item" data-tab="contacts" onclick="switchTab('contacts')">è”ç³»äºº</button>
        <button class="tab-item" data-tab="groups" onclick="switchTab('groups')">ç¾¤ç»„</button>
      </div>

      <!-- ä¼šè¯åˆ—è¡¨ -->
      <div class="conversation-list" id="conversationList">
        <!-- åŠ¨æ€ç”Ÿæˆ -->
      </div>
    </div>

    <!-- ä¸»èŠå¤©åŒºåŸŸ -->
    <div class="main-chat">
      <!-- èŠå¤©å¤´éƒ¨ -->
      <div class="chat-header" id="chatHeader" style="display: none;">
        <button class="icon-btn" onclick="openSidebar()" style="display: none;" id="menuBtn">â˜°</button>
        <div class="chat-avatar" id="chatAvatar">C</div>
        <div class="chat-info">
          <div class="chat-name" id="chatName">é€‰æ‹©ä¸€ä¸ªä¼šè¯</div>
          <div class="chat-status" id="chatStatus">å¼€å§‹èŠå¤©</div>
        </div>
        <div class="chat-actions">
          <button class="icon-btn tooltip" data-tooltip="è¯­éŸ³é€šè¯" onclick="startCall('audio')" id="audioCallBtn">ğŸ“</button>
          <button class="icon-btn tooltip" data-tooltip="è§†é¢‘é€šè¯" onclick="startCall('video')" id="videoCallBtn">ğŸ“¹</button>
          <button class="icon-btn tooltip" data-tooltip="ä¼šè¯ä¿¡æ¯" onclick="openInfo()">â„¹ï¸</button>
        </div>
      </div>

      <!-- ç©ºçŠ¶æ€ -->
      <div class="empty-state" id="emptyState">
        <div class="empty-icon">ğŸ’¬</div>
        <div class="empty-title">æ¬¢è¿ä½¿ç”¨ GO-IM</div>
        <div class="empty-subtitle">é€‰æ‹©ä¸€ä¸ªä¼šè¯å¼€å§‹èŠå¤©ï¼Œæˆ–åˆ›å»ºæ–°çš„ä¼šè¯</div>
      </div>

      <!-- æ¶ˆæ¯å®¹å™¨ -->
      <div class="messages-container hidden" id="messagesContainer">
        <!-- åŠ¨æ€ç”Ÿæˆæ¶ˆæ¯ -->
      </div>

      <!-- è¾“å…¥çŠ¶æ€æç¤º -->
      <div class="typing-indicator hidden" id="typingIndicator">
        å¯¹æ–¹æ­£åœ¨è¾“å…¥...
      </div>

      <!-- å¼•ç”¨æ¶ˆæ¯é¢„è§ˆ -->
      <div class="message-reply hidden" id="replyPreview">
        <button class="message-reply-close" onclick="cancelReply()">âœ•</button>
        <div class="message-reply-author" id="replyAuthor">ç”¨æˆ·</div>
        <div class="message-reply-content" id="replyContent">æ¶ˆæ¯å†…å®¹...</div>
      </div>

      <!-- è¾“å…¥åŒºåŸŸ -->
      <div class="input-area hidden" id="inputArea">
        <div class="input-container">
          <div class="input-actions">
            <button class="input-btn tooltip" data-tooltip="è¡¨æƒ…" onclick="toggleEmoji()">ğŸ˜Š</button>
            <button class="input-btn tooltip" data-tooltip="æ–‡ä»¶" onclick="selectFile()">ğŸ“</button>
            <button class="input-btn tooltip" data-tooltip="å›¾ç‰‡" onclick="selectImage()">ğŸ–¼ï¸</button>
          </div>
          <textarea class="message-input" placeholder="è¾“å…¥æ¶ˆæ¯..." id="messageInput" rows="1"></textarea>
          <button class="send-btn" id="sendBtn" onclick="sendMessage()" disabled>
            <span>â¤</span>
          </button>
        </div>
      </div>
    </div>

    <!-- å³ä¾§ä¿¡æ¯é¢æ¿ -->
    <div class="info-panel" id="infoPanel">
      <div class="user-header">
        <div class="user-info">
          <div class="user-name">ä¼šè¯ä¿¡æ¯</div>
        </div>
        <div class="user-actions">
          <button class="icon-btn" onclick="closeInfo()">âœ•</button>
        </div>
      </div>
      <!-- ä¿¡æ¯é¢æ¿å†…å®¹ -->
      <div style="flex: 1; padding: 20px;">
        <p style="color: var(--text-quaternary);">ä¼šè¯è¯¦æƒ…ã€æˆå‘˜åˆ—è¡¨ã€å…±äº«æ–‡ä»¶ç­‰...</p>
      </div>
    </div>
  </div>

  <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
  <input type="file" id="fileInput" style="display: none;" accept="*/*" onchange="handleFileSelect(event)">
  <input type="file" id="imageInput" style="display: none;" accept="image/*" onchange="handleImageSelect(event)">

  <script>
    // å…¨å±€å˜é‡
    let ws = null;
    let currentUser = null;
    let currentConversation = null;
    let conversations = new Map();
    let contacts = new Map();
    let groups = new Map();
    let isConnected = false;
    let reconnectTimer = null;
    let reconnectDelay = 1000;
    const maxReconnectDelay = 30000;

    // WebRTC é€šè¯ç›¸å…³
    let peerConnection = null;
    let localStream = null;
    let remoteStream = null;
    let currentCall = null;
    let iceServers = [];
    let callStartTime = null;
    let callStatsInterval = null;
    let pendingCandidates = [];

    // é«˜çº§æ¶ˆæ¯åŠŸèƒ½
    let replyToMessage = null;
    let mentionPicker = null;
    let messageMenu = null;
    let selectedMentionIndex = -1;
    let mentionUsers = [];

    // åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', () => {
      initializeApp();
      setupEventListeners();
      registerServiceWorker();
      setupPWAInstallPrompt();
      
      // æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„ç™»å½•ä¿¡æ¯
      const savedToken = localStorage.getItem('im_token');
      const savedUserId = localStorage.getItem('im_userId');
      const savedServer = localStorage.getItem('im_server');
      
      if (savedToken && savedUserId && savedServer) {
        document.getElementById('serverUrl').value = savedServer;
        currentUser = { 
          id: savedUserId, 
          token: savedToken,
          serverUrl: savedServer,
          username: localStorage.getItem('im_username') || 'User'
        };
        closeLoginModal();
        connectWebSocket();
      }
    });

    function initializeApp() {
      // è®¾ç½®å“åº”å¼
      updateLayoutForScreen();
      window.addEventListener('resize', updateLayoutForScreen);
      
      // è‡ªåŠ¨è°ƒæ•´è¾“å…¥æ¡†é«˜åº¦
      const messageInput = document.getElementById('messageInput');
      messageInput.addEventListener('input', autoResizeInput);
      messageInput.addEventListener('keydown', handleKeyDown);
    }

    function setupEventListeners() {
      // æœç´¢åŠŸèƒ½
      document.getElementById('searchInput').addEventListener('input', handleSearch);
      
      // ç›‘å¬è¾“å…¥çŠ¶æ€
      let typingTimer = null;
      let isTyping = false;
      
      document.getElementById('messageInput').addEventListener('input', () => {
        if (!isTyping && currentConversation) {
          isTyping = true;
          sendTypingStatus(true);
        }
        
        clearTimeout(typingTimer);
        typingTimer = setTimeout(() => {
          if (isTyping) {
            isTyping = false;
            sendTypingStatus(false);
          }
        }, 1000);
        
        // æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
        updateSendButton();
      });
    }

    // å“åº”å¼å¸ƒå±€
    function updateLayoutForScreen() {
      const isMobile = window.innerWidth <= 768;
      const menuBtn = document.getElementById('menuBtn');
      
      if (isMobile) {
        menuBtn.style.display = 'flex';
      } else {
        menuBtn.style.display = 'none';
        closePanels();
      }
    }

    // ç™»å½•ç›¸å…³
    async function login() {
      const username = document.getElementById('username').value.trim();
      const password = document.getElementById('password').value.trim();
      const serverUrl = document.getElementById('serverUrl').value.trim();
      
      if (!username || !password || !serverUrl) {
        showToast('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯');
        return;
      }
      
      const loginBtn = document.getElementById('loginBtn');
      loginBtn.disabled = true;
      loginBtn.innerHTML = '<span class="loading"></span> ç™»å½•ä¸­...';
      
      try {
        const response = await fetch(`${serverUrl}/api/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password })
        });
        
        const data = await response.json();
        
        if (response.ok && data.token) {
          currentUser = {
            id: data.userId,
            username: username,
            token: data.token,
            serverUrl: serverUrl
          };
          
          // ä¿å­˜ç™»å½•ä¿¡æ¯
          localStorage.setItem('im_token', data.token);
          localStorage.setItem('im_userId', data.userId);
          localStorage.setItem('im_server', serverUrl);
          localStorage.setItem('im_username', username);
          
          // æ›´æ–°UI
          document.getElementById('userName').textContent = username;
          document.getElementById('userAvatar').textContent = username.charAt(0).toUpperCase();
          
          closeLoginModal();
          connectWebSocket();
          showToast('ç™»å½•æˆåŠŸ');
        } else {
          showToast(data.message || 'ç™»å½•å¤±è´¥');
        }
      } catch (error) {
        console.error('Login error:', error);
        showToast('ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨åœ°å€');
      } finally {
        loginBtn.disabled = false;
        loginBtn.textContent = 'ç™»å½•';
      }
    }

    async function register() {
      const username = document.getElementById('username').value.trim();
      const password = document.getElementById('password').value.trim();
      const nickname = document.getElementById('nickname').value.trim();
      const serverUrl = document.getElementById('serverUrl').value.trim();
      
      if (!username || !password || !serverUrl) {
        showToast('è¯·å¡«å†™ç”¨æˆ·åã€å¯†ç å’ŒæœåŠ¡å™¨åœ°å€');
        return;
      }
      
      const registerBtn = document.getElementById('registerBtn');
      registerBtn.disabled = true;
      registerBtn.innerHTML = '<span class="loading"></span> æ³¨å†Œä¸­...';
      
      try {
        const response = await fetch(`${serverUrl}/api/register`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password, nickname: nickname || username })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          showToast('æ³¨å†ŒæˆåŠŸï¼Œè¯·ç™»å½•');
          // æ¸…ç©ºæ˜µç§°æ¡†ï¼Œä¿ç•™å…¶ä»–ä¿¡æ¯ä¾¿äºç™»å½•
          document.getElementById('nickname').value = '';
        } else {
          showToast(data.message || 'æ³¨å†Œå¤±è´¥');
        }
      } catch (error) {
        console.error('Register error:', error);
        showToast('ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨åœ°å€');
      } finally {
        registerBtn.disabled = false;
        registerBtn.textContent = 'æ³¨å†Œ';
      }
    }

    function logout() {
      if (ws) {
        ws.close();
        ws = null;
      }
      
      currentUser = null;
      currentConversation = null;
      conversations.clear();
      contacts.clear();
      groups.clear();
      
      localStorage.removeItem('im_token');
      localStorage.removeItem('im_userId');
      localStorage.removeItem('im_server');
      localStorage.removeItem('im_username');
      
      document.getElementById('appContainer').style.display = 'none';
      document.getElementById('loginModal').style.display = 'flex';
      
      updateConnectionStatus(false);
      showToast('å·²é€€å‡ºç™»å½•');
    }

    function closeLoginModal() {
      document.getElementById('loginModal').style.display = 'none';
      document.getElementById('appContainer').style.display = 'flex';
    }

    // WebSocket è¿æ¥
    function connectWebSocket() {
      if (!currentUser) return;
      
      const wsUrl = currentUser.serverUrl.replace('http', 'ws') + '/ws';
      const deviceId = 'web-' + Date.now();
      const fullUrl = `${wsUrl}?token=${currentUser.token}&deviceId=${deviceId}`;
      
      updateConnectionStatus('connecting');
      
      ws = new WebSocket(fullUrl);
      
      ws.onopen = () => {
        updateConnectionStatus(true);
        reconnectDelay = 1000;
        clearTimeout(reconnectTimer);
        loadInitialData();
      };
      
      ws.onclose = () => {
        updateConnectionStatus(false);
        scheduleReconnect();
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        updateConnectionStatus(false);
      };
      
      ws.onmessage = (event) => {
        handleWebSocketMessage(event.data);
      };
    }

    function scheduleReconnect() {
      if (reconnectTimer) return;
      
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        if (currentUser) {
          connectWebSocket();
          reconnectDelay = Math.min(reconnectDelay * 2, maxReconnectDelay);
        }
      }, reconnectDelay);
    }

    function updateConnectionStatus(status) {
      const dot = document.getElementById('connectionDot');
      const text = document.getElementById('connectionText');
      
      dot.className = 'status-dot';
      
      if (status === true) {
        isConnected = true;
        dot.classList.add('connected');
        text.textContent = 'å·²è¿æ¥';
      } else if (status === 'connecting') {
        isConnected = false;
        dot.classList.add('connecting');
        text.textContent = 'è¿æ¥ä¸­...';
      } else {
        isConnected = false;
        text.textContent = 'æœªè¿æ¥';
      }
    }

    // WebSocket æ¶ˆæ¯å¤„ç†
    function handleWebSocketMessage(data) {
      try {
        const message = JSON.parse(data);
        
        switch (message.action) {
          case 'message':
            handleIncomingMessage(message.data);
            break;
          case 'ack':
            handleMessageAck(message.data);
            break;
          case 'typing':
            handleTypingStatus(message.data);
            break;
          case 'conversation_updated':
            handleConversationUpdate(message.data);
            break;
          case 'call_incoming':
          case 'call_started':
          case 'call_answered':
          case 'call_rejected':
          case 'call_ended':
          case 'webrtc_signaling':
            handleCallEvent(message);
            break;
            
          case 'message_recalled':
            handleMessageRecalled(message.data);
            break;
          default:
            console.log('Unhandled message:', message);
        }
      } catch (error) {
        console.error('Error handling WebSocket message:', error);
      }
    }

    // åˆå§‹æ•°æ®åŠ è½½
    async function loadInitialData() {
      try {
        // åŠ è½½ä¼šè¯åˆ—è¡¨
        await loadConversations();
        
        // åŠ è½½è”ç³»äºº
        await loadContacts();
        
        // åŠ è½½ç¾¤ç»„
        await loadGroups();
        
      } catch (error) {
        console.error('Error loading initial data:', error);
      }
    }

    async function loadConversations() {
      try {
        const response = await apiRequest('/api/conversations?limit=50');
        if (response.conversations) {
          response.conversations.forEach(conv => {
            conversations.set(conv.convId, conv);
          });
          renderConversationList();
        }
      } catch (error) {
        console.error('Error loading conversations:', error);
      }
    }

    async function loadContacts() {
      try {
        const response = await apiRequest('/api/friends');
        if (response.friends) {
          contacts.clear();
          response.friends.forEach(friend => {
            contacts.set(friend.id, {
              id: friend.id,
              username: friend.username,
              nickname: friend.nickname,
              avatarUrl: friend.avatarUrl,
              remark: friend.remark,
              createdAt: friend.createdAt,
              online: false // å¯ä»¥é€šè¿‡å…¶ä»–APIè·å–åœ¨çº¿çŠ¶æ€
            });
          });
        }
      } catch (error) {
        console.error('Error loading contacts:', error);
      }
    }

    async function loadGroups() {
      try {
        const response = await apiRequest('/api/groups');
        if (response.groups) {
          groups.clear();
          response.groups.forEach(group => {
            groups.set(group.id, {
              id: group.id,
              name: group.name,
              ownerId: group.ownerId,
              muted: group.muted,
              memberCount: group.memberCount || 0,
              role: group.role,
              remark: group.remark,
              joinTime: group.joinTime,
              createdAt: group.createdAt
            });
          });
        }
      } catch (error) {
        console.error('Error loading groups:', error);
      }
    }

    // API è¯·æ±‚å°è£…
    async function apiRequest(path, options = {}) {
      if (!currentUser) throw new Error('æœªç™»å½•');
      
      const response = await fetch(currentUser.serverUrl + path, {
        headers: {
          'Authorization': `Bearer ${currentUser.token}`,
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...options
      });
      
      if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`);
      }
      
      return await response.json();
    }

    // æ ‡ç­¾é¡µåˆ‡æ¢
    function switchTab(tabName) {
      document.querySelectorAll('.tab-item').forEach(item => {
        item.classList.remove('active');
      });
      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
      
      // æ ¹æ®æ ‡ç­¾é¡µåŠ è½½ä¸åŒå†…å®¹
      switch (tabName) {
        case 'chats':
          renderConversationList();
          break;
        case 'contacts':
          renderContactList();
          break;
        case 'groups':
          renderGroupList();
          break;
      }
    }

    // æ¸²æŸ“ä¼šè¯åˆ—è¡¨
    function renderConversationList() {
      const container = document.getElementById('conversationList');
      container.innerHTML = '';
      
      if (conversations.size === 0) {
        container.innerHTML = `
          <div class="empty-state" style="padding: 40px 20px;">
            <div class="empty-icon">ğŸ’¬</div>
            <div class="empty-title">æš‚æ— ä¼šè¯</div>
            <div class="empty-subtitle">å¼€å§‹æ–°çš„å¯¹è¯å§</div>
          </div>
        `;
        return;
      }
      
      // æŒ‰æœ€åæ¶ˆæ¯æ—¶é—´æ’åº
      const sortedConversations = Array.from(conversations.values())
        .sort((a, b) => new Date(b.lastMessageTime || 0) - new Date(a.lastMessageTime || 0));
      
      sortedConversations.forEach(conv => {
        const item = createConversationItem(conv);
        container.appendChild(item);
      });
    }

    function createConversationItem(conversation) {
      const div = document.createElement('div');
      div.className = 'conversation-item';
      div.onclick = () => selectConversation(conversation);
      
      if (currentConversation && currentConversation.convId === conversation.convId) {
        div.classList.add('active');
      }
      
      if (conversation.unreadCount > 0) {
        div.classList.add('unread');
      }
      
      const avatar = conversation.name?.charAt(0)?.toUpperCase() || '?';
      const name = conversation.name || conversation.convId;
      const preview = conversation.lastMessage?.text || 'ç‚¹å‡»å¼€å§‹èŠå¤©';
      const time = conversation.lastMessageTime ? formatTime(new Date(conversation.lastMessageTime)) : '';
      
      div.innerHTML = `
        <div class="conversation-avatar">
          ${avatar}
          ${conversation.online ? '<div class="online-indicator"></div>' : ''}
        </div>
        <div class="conversation-info">
          <div class="conversation-name">${name}</div>
          <div class="conversation-preview">${preview}</div>
        </div>
        <div class="conversation-meta">
          <div class="conversation-time">${time}</div>
          ${conversation.unreadCount > 0 ? `<div class="unread-badge">${conversation.unreadCount}</div>` : ''}
        </div>
      `;
      
      return div;
    }

    function renderContactList() {
      const container = document.getElementById('conversationList');
      container.innerHTML = '';
      
      // æ·»åŠ å¥½å‹æŒ‰é’®
      const addContactBtn = document.createElement('div');
      addContactBtn.className = 'conversation-item';
      addContactBtn.style.cssText = 'background: var(--primary); color: white; cursor: pointer; border-radius: 12px; margin: 12px;';
      addContactBtn.innerHTML = `
        <div class="conversation-avatar" style="background: rgba(255,255,255,0.2);">â•</div>
        <div class="conversation-info">
          <div class="conversation-name">æ·»åŠ å¥½å‹</div>
          <div class="conversation-preview">é€šè¿‡ç”¨æˆ·IDæ·»åŠ å¥½å‹</div>
        </div>
      `;
      addContactBtn.onclick = () => showAddContactDialog();
      container.appendChild(addContactBtn);
      
      if (contacts.size === 0) {
        loadContacts().then(() => {
          if (contacts.size === 0) {
            const emptyDiv = document.createElement('div');
            emptyDiv.className = 'empty-state';
            emptyDiv.style.padding = '40px 20px';
            emptyDiv.innerHTML = `
              <div class="empty-icon">ğŸ‘¥</div>
              <div class="empty-title">æš‚æ— è”ç³»äºº</div>
              <div class="empty-subtitle">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®æ·»åŠ å¥½å‹</div>
            `;
            container.appendChild(emptyDiv);
          }
        });
        return;
      }
      
      // æ¸²æŸ“è”ç³»äººåˆ—è¡¨
      const sortedContacts = Array.from(contacts.values())
        .sort((a, b) => (a.nickname || a.username).localeCompare(b.nickname || b.username));
      
      sortedContacts.forEach(contact => {
        const item = createContactItem(contact);
        container.appendChild(item);
      });
    }

    function renderGroupList() {
      const container = document.getElementById('conversationList');
      container.innerHTML = '';
      
      // åˆ›å»ºç¾¤ç»„æŒ‰é’®
      const createGroupBtn = document.createElement('div');
      createGroupBtn.className = 'conversation-item';
      createGroupBtn.style.cssText = 'background: var(--success); color: white; cursor: pointer; border-radius: 12px; margin: 12px;';
      createGroupBtn.innerHTML = `
        <div class="conversation-avatar" style="background: rgba(255,255,255,0.2);">â•</div>
        <div class="conversation-info">
          <div class="conversation-name">åˆ›å»ºç¾¤ç»„</div>
          <div class="conversation-preview">åˆ›å»ºæ–°çš„ç¾¤èŠ</div>
        </div>
      `;
      createGroupBtn.onclick = () => showCreateGroupDialog();
      container.appendChild(createGroupBtn);
      
      // åŠ å…¥ç¾¤ç»„æŒ‰é’®
      const joinGroupBtn = document.createElement('div');
      joinGroupBtn.className = 'conversation-item';
      joinGroupBtn.style.cssText = 'background: var(--info); color: white; cursor: pointer; border-radius: 12px; margin: 12px;';
      joinGroupBtn.innerHTML = `
        <div class="conversation-avatar" style="background: rgba(255,255,255,0.2);">ğŸšª</div>
        <div class="conversation-info">
          <div class="conversation-name">åŠ å…¥ç¾¤ç»„</div>
          <div class="conversation-preview">é€šè¿‡ç¾¤ç»„IDåŠ å…¥</div>
        </div>
      `;
      joinGroupBtn.onclick = () => showJoinGroupDialog();
      container.appendChild(joinGroupBtn);
      
      if (groups.size === 0) {
        loadGroups().then(() => {
          if (groups.size === 0) {
            const emptyDiv = document.createElement('div');
            emptyDiv.className = 'empty-state';
            emptyDiv.style.padding = '40px 20px';
            emptyDiv.innerHTML = `
              <div class="empty-icon">ğŸ‘¥</div>
              <div class="empty-title">æš‚æ— ç¾¤ç»„</div>
              <div class="empty-subtitle">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®åˆ›å»ºæˆ–åŠ å…¥ç¾¤ç»„</div>
            `;
            container.appendChild(emptyDiv);
          }
        });
        return;
      }
      
      // æ¸²æŸ“ç¾¤ç»„åˆ—è¡¨
      const sortedGroups = Array.from(groups.values())
        .sort((a, b) => (a.name || '').localeCompare(b.name || ''));
      
      sortedGroups.forEach(group => {
        const item = createGroupItem(group);
        container.appendChild(item);
      });
    }

    // ä¼šè¯é€‰æ‹©
    function selectConversation(conversation) {
      currentConversation = conversation;
      
      // æ›´æ–°ä¼šè¯åˆ—è¡¨é€‰ä¸­çŠ¶æ€
      document.querySelectorAll('.conversation-item').forEach(item => {
        item.classList.remove('active');
      });
      event.currentTarget?.classList.add('active');
      
      // æ˜¾ç¤ºèŠå¤©ç•Œé¢
      showChatInterface();
      
      // æ›´æ–°é€šè¯æŒ‰é’®çŠ¶æ€
      updateCallButtons();
      
      // åŠ è½½æ¶ˆæ¯å†å²
      loadMessageHistory(conversation.convId);
      
      // æ ‡è®°å·²è¯»
      markConversationRead(conversation.convId);
      
      // ç§»åŠ¨ç«¯è‡ªåŠ¨å…³é—­ä¾§è¾¹æ 
      if (window.innerWidth <= 768) {
        closePanels();
      }
    }

    function updateCallButtons() {
      const audioCallBtn = document.getElementById('audioCallBtn');
      const videoCallBtn = document.getElementById('videoCallBtn');
      
      if (audioCallBtn && videoCallBtn && currentConversation) {
        const isC2C = currentConversation.type === 'c2c';
        audioCallBtn.disabled = !isC2C;
        videoCallBtn.disabled = !isC2C;
        audioCallBtn.style.opacity = isC2C ? '1' : '0.5';
        videoCallBtn.style.opacity = isC2C ? '1' : '0.5';
        
        if (!isC2C) {
          audioCallBtn.setAttribute('data-tooltip', 'ç¾¤ç»„é€šè¯åŠŸèƒ½å¼€å‘ä¸­');
          videoCallBtn.setAttribute('data-tooltip', 'ç¾¤ç»„é€šè¯åŠŸèƒ½å¼€å‘ä¸­');
        } else {
          audioCallBtn.setAttribute('data-tooltip', 'è¯­éŸ³é€šè¯');
          videoCallBtn.setAttribute('data-tooltip', 'è§†é¢‘é€šè¯');
        }
      }
    }

    function showChatInterface() {
      if (!currentConversation) return;
      
      // éšè—ç©ºçŠ¶æ€ï¼Œæ˜¾ç¤ºèŠå¤©ç•Œé¢
      document.getElementById('emptyState').style.display = 'none';
      document.getElementById('chatHeader').style.display = 'flex';
      document.getElementById('messagesContainer').classList.remove('hidden');
      document.getElementById('inputArea').classList.remove('hidden');
      
      // æ›´æ–°èŠå¤©å¤´éƒ¨ä¿¡æ¯
      const avatar = currentConversation.name?.charAt(0)?.toUpperCase() || '?';
      document.getElementById('chatAvatar').textContent = avatar;
      document.getElementById('chatName').textContent = currentConversation.name || currentConversation.convId;
      document.getElementById('chatStatus').textContent = currentConversation.online ? 'åœ¨çº¿' : 'ç¦»çº¿';
    }

    // æ¶ˆæ¯å¤„ç†
    async function loadMessageHistory(convId) {
      try {
        const response = await apiRequest(`/api/conversations/${convId}/messages?limit=50`);
        const container = document.getElementById('messagesContainer');
        container.innerHTML = '';
        
        if (response.messages && response.messages.length > 0) {
          response.messages.forEach(message => {
            addMessageToUI(message);
          });
          scrollToBottom();
        }
      } catch (error) {
        console.error('Error loading messages:', error);
      }
    }

    function addMessageToUI(message) {
      const container = document.getElementById('messagesContainer');
      const messageEl = createMessageElement(message);
      container.appendChild(messageEl);
    }

    function createMessageElement(message) {
      const div = document.createElement('div');
      div.className = 'message-group';
      div.setAttribute('data-message-id', message.id || message.clientMsgId);
      
      const isSent = message.fromUserId === currentUser.id;
      div.classList.add(isSent ? 'sent' : 'received');
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯æ’¤å›çš„æ¶ˆæ¯
      if (message.recalled) {
        div.classList.add('message-recalled');
      }
      
      // æ·»åŠ å¼•ç”¨æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
      if (message.replyTo) {
        const replyDiv = document.createElement('div');
        replyDiv.className = 'message-reply';
        replyDiv.innerHTML = `
          <div class="message-reply-author">${message.replyTo.fromUserName || message.replyTo.fromUserId}</div>
          <div class="message-reply-content">${message.replyTo.text}</div>
        `;
        replyDiv.onclick = () => scrollToMessage(message.replyTo.messageId);
        div.appendChild(replyDiv);
      }
      
      const messageItem = document.createElement('div');
      messageItem.className = 'message-item';
      messageItem.classList.add(isSent ? 'sent' : 'received');
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.classList.add(isSent ? 'sent' : 'received');
      
      // æ·»åŠ å³é”®èœå•
      bubble.addEventListener('contextmenu', (e) => {
        showMessageMenu(e, message);
      });
      
      // å¤„ç†ä¸åŒç±»å‹çš„æ¶ˆæ¯
      switch (message.type) {
        case 'text':
          if (message.recalled) {
            bubble.textContent = 'æ­¤æ¶ˆæ¯å·²è¢«æ’¤å›';
          } else {
            const text = message.payload?.text || '';
            bubble.innerHTML = renderMessageWithMentions(text);
          }
          break;
        case 'image':
          if (message.recalled) {
            bubble.textContent = 'æ­¤æ¶ˆæ¯å·²è¢«æ’¤å›';
          } else {
            bubble.innerHTML = `<img src="${message.payload?.url}" alt="å›¾ç‰‡" style="max-width: 200px; border-radius: 8px;">`;
          }
          break;
        case 'file':
          if (message.recalled) {
            bubble.textContent = 'æ­¤æ¶ˆæ¯å·²è¢«æ’¤å›';
          } else {
            bubble.innerHTML = `
              <div style="display: flex; align-items: center; gap: 8px;">
                <span>ğŸ“</span>
                <span>${message.payload?.name || 'æ–‡ä»¶'}</span>
              </div>
            `;
          }
          break;
        default:
          bubble.textContent = message.recalled ? 'æ­¤æ¶ˆæ¯å·²è¢«æ’¤å›' : (message.payload?.text || '[ä¸æ”¯æŒçš„æ¶ˆæ¯ç±»å‹]');
      }
      
      const time = document.createElement('div');
      time.className = 'message-time';
      time.textContent = formatTime(new Date(message.createdAt));
      
      if (isSent) {
        const status = document.createElement('div');
        status.className = 'message-status';
        status.textContent = getMessageStatusIcon(message.status);
        messageItem.appendChild(bubble);
        messageItem.appendChild(time);
        messageItem.appendChild(status);
      } else {
        messageItem.appendChild(bubble);
        messageItem.appendChild(time);
      }
      
      div.appendChild(messageItem);
      return div;
    }

    function scrollToMessage(messageId) {
      const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
      if (messageEl) {
        messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // é«˜äº®æ•ˆæœ
        messageEl.style.backgroundColor = 'var(--bg-overlay)';
        setTimeout(() => {
          messageEl.style.backgroundColor = '';
        }, 2000);
      }
    }

    function handleIncomingMessage(message) {
      // æ›´æ–°ä¼šè¯åˆ—è¡¨
      if (conversations.has(message.convId)) {
        const conv = conversations.get(message.convId);
        conv.lastMessage = message;
        conv.lastMessageTime = message.createdAt;
        
        if (currentConversation?.convId !== message.convId) {
          conv.unreadCount = (conv.unreadCount || 0) + 1;
        }
      } else {
        // åˆ›å»ºæ–°ä¼šè¯
        conversations.set(message.convId, {
          convId: message.convId,
          name: message.fromUserName || message.fromUserId,
          lastMessage: message,
          lastMessageTime: message.createdAt,
          unreadCount: currentConversation?.convId !== message.convId ? 1 : 0
        });
      }
      
      // å¦‚æœæ˜¯å½“å‰ä¼šè¯ï¼Œæ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨
      if (currentConversation?.convId === message.convId) {
        addMessageToUI(message);
        scrollToBottom();
        markConversationRead(message.convId);
      }
      
      // é‡æ–°æ¸²æŸ“ä¼šè¯åˆ—è¡¨
      if (document.querySelector('[data-tab="chats"]').classList.contains('active')) {
        renderConversationList();
      }
      
      // æ˜¾ç¤ºæ¡Œé¢é€šçŸ¥
      if (currentConversation?.convId !== message.convId) {
        showNotification(message);
      }
    }

    function handleMessageAck(data) {
      // å¤„ç†æ¶ˆæ¯ç¡®è®¤
      console.log('Message acknowledged:', data);
    }

    function handleTypingStatus(data) {
      if (currentConversation?.convId === data.convId) {
        const indicator = document.getElementById('typingIndicator');
        if (data.typing) {
          indicator.classList.remove('hidden');
        } else {
          indicator.classList.add('hidden');
        }
      }
    }

    // å‘é€æ¶ˆæ¯
    function sendMessage() {
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      
      if (!text || !currentConversation || !isConnected) return;
      
      // æ£€æµ‹@æåŠ
      const mentions = extractMentions(text);
      
      const payload = { 
        text: text,
        mentions: mentions.length > 0 ? mentions : undefined
      };
      
      const message = {
        action: 'send',
        data: {
          convId: currentConversation.convId,
          convType: currentConversation.type || 'c2c',
          clientMsgId: 'msg-' + Date.now(),
          type: 'text',
          payload: payload
        }
      };
      
      // æ·»åŠ å¼•ç”¨ä¿¡æ¯
      if (replyToMessage) {
        message.data.replyTo = {
          messageId: replyToMessage.id,
          seq: replyToMessage.seq,
          fromUserId: replyToMessage.fromUserId,
          text: getMessagePreviewText(replyToMessage)
        };
      }
      
      // æ·»åŠ æ¥æ”¶è€…ä¿¡æ¯
      if (currentConversation.type === 'group') {
        message.data.groupId = currentConversation.groupId;
      } else {
        message.data.to = currentConversation.userId;
      }
      
      ws.send(JSON.stringify(message));
      
      // æ¸…ç©ºè¾“å…¥æ¡†å’Œå¼•ç”¨
      input.value = '';
      cancelReply();
      updateSendButton();
      autoResizeInput();
      
      // ç«‹å³æ·»åŠ åˆ°UIï¼ˆä¹è§‚æ›´æ–°ï¼‰
      const optimisticMessage = {
        ...message.data,
        fromUserId: currentUser.id,
        fromUserName: currentUser.username,
        createdAt: new Date().toISOString(),
        status: 'sending'
      };
      addMessageToUI(optimisticMessage);
      scrollToBottom();
    }

    function extractMentions(text) {
      const mentionRegex = /@(\w+)/g;
      const mentions = [];
      let match;
      
      while ((match = mentionRegex.exec(text)) !== null) {
        const username = match[1];
        // æŸ¥æ‰¾å¯¹åº”çš„ç”¨æˆ·ID
        const user = Array.from(contacts.values()).find(c => c.username === username);
        if (user) {
          mentions.push({
            userId: user.id,
            username: username,
            start: match.index,
            length: match[0].length
          });
        }
      }
      
      return mentions;
    }

    function sendTypingStatus(isTyping) {
      if (!currentConversation || !isConnected) return;
      
      const message = {
        action: 'typing',
        data: {
          convId: currentConversation.convId,
          convType: currentConversation.type || 'c2c',
          typing: isTyping
        }
      };
      
      ws.send(JSON.stringify(message));
    }

    // å·¥å…·å‡½æ•°
    function formatTime(date) {
      const now = new Date();
      const diff = now - date;
      
      if (diff < 60000) return 'åˆšåˆš';
      if (diff < 3600000) return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
      if (diff < 86400000) return Math.floor(diff / 3600000) + 'å°æ—¶å‰';
      if (diff < 604800000) return Math.floor(diff / 86400000) + 'å¤©å‰';
      
      return date.toLocaleDateString();
    }

    function getMessageStatusIcon(status) {
      switch (status) {
        case 'sending': return 'â³';
        case 'sent': return 'âœ“';
        case 'delivered': return 'âœ“âœ“';
        case 'read': return 'ğŸ‘ï¸';
        default: return '';
      }
    }

    function autoResizeInput() {
      const input = document.getElementById('messageInput');
      input.style.height = 'auto';
      input.style.height = Math.min(input.scrollHeight, 120) + 'px';
    }

    function updateSendButton() {
      const input = document.getElementById('messageInput');
      const btn = document.getElementById('sendBtn');
      btn.disabled = !input.value.trim() || !isConnected;
    }

    function handleKeyDown(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    }

    function scrollToBottom() {
      const container = document.getElementById('messagesContainer');
      container.scrollTop = container.scrollHeight;
    }

    function markConversationRead(convId) {
      if (conversations.has(convId)) {
        conversations.get(convId).unreadCount = 0;
      }
    }

    // UI äº¤äº’
    function openSidebar() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('overlay');
      sidebar.classList.add('open');
      overlay.classList.add('show');
    }

    function openInfo() {
      const panel = document.getElementById('infoPanel');
      const overlay = document.getElementById('overlay');
      panel.classList.add('open');
      overlay.classList.add('show');
    }

    function closeInfo() {
      const panel = document.getElementById('infoPanel');
      panel.classList.remove('open');
      document.getElementById('overlay').classList.remove('show');
    }

    function closePanels() {
      document.getElementById('sidebar').classList.remove('open');
      document.getElementById('infoPanel').classList.remove('open');
      document.getElementById('overlay').classList.remove('show');
    }

    function openSettings() {
      showToast('è®¾ç½®åŠŸèƒ½å¼€å‘ä¸­...');
    }

    function handleSearch() {
      const query = document.getElementById('searchInput').value.toLowerCase().trim();
      
      if (!query) {
        // æ¸…ç©ºæœç´¢ï¼Œæ˜¾ç¤ºæ­£å¸¸åˆ—è¡¨
        const activeTab = document.querySelector('.tab-item.active');
        if (activeTab) {
          const tabName = activeTab.getAttribute('data-tab');
          switch (tabName) {
            case 'chats': renderConversationList(); break;
            case 'contacts': renderContactList(); break;
            case 'groups': renderGroupList(); break;
          }
        }
        return;
      }
      
      // æœç´¢ä¼šè¯ã€è”ç³»äººæˆ–ç¾¤ç»„
      const activeTab = document.querySelector('.tab-item.active');
      if (activeTab) {
        const tabName = activeTab.getAttribute('data-tab');
        switch (tabName) {
          case 'chats': searchConversations(query); break;
          case 'contacts': searchContacts(query); break;
          case 'groups': searchGroups(query); break;
        }
      }
    }

    function searchConversations(query) {
      const container = document.getElementById('conversationList');
      container.innerHTML = '';
      
      const filteredConversations = Array.from(conversations.values()).filter(conv => {
        const name = (conv.name || '').toLowerCase();
        const preview = (conv.lastMessage?.text || '').toLowerCase();
        return name.includes(query) || preview.includes(query);
      });
      
      if (filteredConversations.length === 0) {
        container.innerHTML = `
          <div class="empty-state" style="padding: 40px 20px;">
            <div class="empty-icon">ğŸ”</div>
            <div class="empty-title">æœªæ‰¾åˆ°ç›¸å…³ä¼šè¯</div>
            <div class="empty-subtitle">å°è¯•æœç´¢å…¶ä»–å…³é”®è¯</div>
          </div>
        `;
        return;
      }
      
      filteredConversations.forEach(conv => {
        const item = createConversationItem(conv);
        container.appendChild(item);
      });
    }

    function searchContacts(query) {
      const container = document.getElementById('conversationList');
      container.innerHTML = '';
      
      const filteredContacts = Array.from(contacts.values()).filter(contact => {
        const name = (contact.nickname || contact.username || '').toLowerCase();
        return name.includes(query);
      });
      
      if (filteredContacts.length === 0) {
        container.innerHTML = `
          <div class="empty-state" style="padding: 40px 20px;">
            <div class="empty-icon">ğŸ”</div>
            <div class="empty-title">æœªæ‰¾åˆ°ç›¸å…³è”ç³»äºº</div>
            <div class="empty-subtitle">å°è¯•æœç´¢å…¶ä»–å…³é”®è¯</div>
          </div>
        `;
        return;
      }
      
      filteredContacts.forEach(contact => {
        const item = createContactItem(contact);
        container.appendChild(item);
      });
    }

    function searchGroups(query) {
      const container = document.getElementById('conversationList');
      container.innerHTML = '';
      
      const filteredGroups = Array.from(groups.values()).filter(group => {
        const name = (group.name || '').toLowerCase();
        const desc = (group.description || '').toLowerCase();
        return name.includes(query) || desc.includes(query);
      });
      
      if (filteredGroups.length === 0) {
        container.innerHTML = `
          <div class="empty-state" style="padding: 40px 20px;">
            <div class="empty-icon">ğŸ”</div>
            <div class="empty-title">æœªæ‰¾åˆ°ç›¸å…³ç¾¤ç»„</div>
            <div class="empty-subtitle">å°è¯•æœç´¢å…¶ä»–å…³é”®è¯</div>
          </div>
        `;
        return;
      }
      
      filteredGroups.forEach(group => {
        const item = createGroupItem(group);
        container.appendChild(item);
      });
    }

    // æ–‡ä»¶å¤„ç†
    function selectFile() {
      document.getElementById('fileInput').click();
    }

    function selectImage() {
      document.getElementById('imageInput').click();
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (file) {
        uploadFile(file);
      }
    }

    function handleImageSelect(event) {
      const file = event.target.files[0];
      if (file) {
        uploadFile(file);
      }
    }

    async function uploadFile(file) {
      try {
        showToast('æ–‡ä»¶ä¸Šä¼ ä¸­...');
        
        const formData = new FormData();
        formData.append('file', file);
        
        const response = await fetch(currentUser.serverUrl + '/api/files/upload', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${currentUser.token}`
          },
          body: formData
        });
        
        const result = await response.json();
        
        if (response.ok) {
          // å‘é€æ–‡ä»¶æ¶ˆæ¯
          sendFileMessage(result, file);
          showToast('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ');
        } else {
          showToast('æ–‡ä»¶ä¸Šä¼ å¤±è´¥');
        }
      } catch (error) {
        console.error('File upload error:', error);
        showToast('æ–‡ä»¶ä¸Šä¼ å¤±è´¥');
      }
    }

    function sendFileMessage(fileInfo, file) {
      if (!currentConversation || !isConnected) return;
      
      const message = {
        action: 'send',
        data: {
          convId: currentConversation.convId,
          convType: currentConversation.type || 'c2c',
          clientMsgId: 'file-' + Date.now(),
          type: file.type.startsWith('image/') ? 'image' : 'file',
          payload: {
            url: fileInfo.url,
            name: fileInfo.fileName,
            size: fileInfo.fileSize,
            mimeType: fileInfo.mimeType
          }
        }
      };
      
      if (currentConversation.type === 'group') {
        message.data.groupId = currentConversation.groupId;
      } else {
        message.data.to = currentConversation.userId;
      }
      
      ws.send(JSON.stringify(message));
    }

    // WebRTC éŸ³è§†é¢‘é€šè¯åŠŸèƒ½
    async function initWebRTC() {
      try {
        const response = await apiRequest('/api/webrtc/ice-servers');
        if (response.iceServers) {
          iceServers = response.iceServers;
        }
      } catch (error) {
        console.error('è·å–ICEæœåŠ¡å™¨å¤±è´¥:', error);
        // ä½¿ç”¨é»˜è®¤STUNæœåŠ¡å™¨
        iceServers = [{ urls: 'stun:stun.l.google.com:19302' }];
      }
    }

    function createPeerConnection() {
      const config = { 
        iceServers: iceServers.length > 0 ? iceServers : [{ urls: 'stun:stun.l.google.com:19302' }] 
      };
      
      peerConnection = new RTCPeerConnection(config);
      
      peerConnection.onicecandidate = (event) => {
        if (event.candidate && currentCall) {
          const candidate = event.candidate.toJSON ? event.candidate.toJSON() : event.candidate;
          sendWebRTCMessage({
            type: 'candidate',
            candidate: candidate
          });
        }
      };
      
      peerConnection.ontrack = (event) => {
        console.log('æ”¶åˆ°è¿œç¨‹æµ:', event);
        const remoteVideo = document.getElementById('callRemoteVideo');
        if (remoteVideo && event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];
          remoteStream = event.streams[0];
        }
      };
      
      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        console.log('è¿æ¥çŠ¶æ€:', state);
        updateCallStatus(state);
        
        if (state === 'connected') {
          startCallTimer();
          startCallStatsMonitoring();
        } else if (state === 'disconnected' || state === 'failed') {
          endCall();
        }
      };
      
      peerConnection.oniceconnectionstatechange = () => {
        console.log('ICEè¿æ¥çŠ¶æ€:', peerConnection.iceConnectionState);
      };
      
      return peerConnection;
    }

    async function startCall(type) {
      if (!currentConversation) {
        showToast('è¯·å…ˆé€‰æ‹©ä¼šè¯');
        return;
      }
      
      if (currentConversation.type === 'group') {
        showToast('ç¾¤ç»„é€šè¯åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­');
        return;
      }
      
      try {
        // è·å–æœ¬åœ°åª’ä½“æµ
        await getLocalStream(type === 'video');
        
        // å‘é€é€šè¯è¯·æ±‚
        const message = {
          action: 'call_start',
          data: {
            to: currentConversation.userId,
            type: type
          }
        };
        
        ws.send(JSON.stringify(message));
        console.log('å‘èµ·é€šè¯:', type, currentConversation.userId);
        
      } catch (error) {
        console.error('å‘èµ·é€šè¯å¤±è´¥:', error);
        showToast('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£');
      }
    }

    async function answerCall() {
      if (!currentCall) return;
      
      try {
        // è·å–æœ¬åœ°åª’ä½“æµ
        await getLocalStream(currentCall.type === 'video');
        
        // åˆ›å»ºPeerConnectionå¹¶æ·»åŠ æœ¬åœ°æµ
        createPeerConnection();
        if (localStream) {
          localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
          });
        }
        
        // å‘é€æ¥å¬æ¶ˆæ¯
        const message = {
          action: 'call_answer',
          data: {
            callId: currentCall.id
          }
        };
        
        ws.send(JSON.stringify(message));
        console.log('æ¥å¬é€šè¯:', currentCall.id);
        
      } catch (error) {
        console.error('æ¥å¬é€šè¯å¤±è´¥:', error);
        showToast('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£');
      }
    }

    function rejectCall() {
      if (!currentCall) return;
      
      const message = {
        action: 'call_reject',
        data: {
          callId: currentCall.id
        }
      };
      
      ws.send(JSON.stringify(message));
      cleanupCall();
    }

    function endCall() {
      if (!currentCall) return;
      
      const message = {
        action: 'call_end',
        data: {
          callId: currentCall.id
        }
      };
      
      ws.send(JSON.stringify(message));
      cleanupCall();
    }

    async function getLocalStream(video = false) {
      try {
        const constraints = {
          audio: true,
          video: video
        };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // æ˜¾ç¤ºæœ¬åœ°è§†é¢‘
        const localVideo = document.getElementById('callLocalVideo');
        if (localVideo) {
          localVideo.srcObject = localStream;
        }
        
        return localStream;
      } catch (error) {
        console.error('è·å–åª’ä½“æµå¤±è´¥:', error);
        throw error;
      }
    }

    function cleanupCall() {
      // åœæ­¢æœ¬åœ°æµ
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      // å…³é—­PeerConnection
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      
      // æ¸…ç†è¿œç¨‹æµ
      const remoteVideo = document.getElementById('callRemoteVideo');
      if (remoteVideo) {
        remoteVideo.srcObject = null;
      }
      
      // åœæ­¢è®¡æ—¶å™¨å’Œç»Ÿè®¡
      stopCallTimer();
      stopCallStatsMonitoring();
      
      // æ¸…ç†å…¨å±€çŠ¶æ€
      currentCall = null;
      remoteStream = null;
      pendingCandidates = [];
      
      // éšè—é€šè¯ç•Œé¢
      hideCallOverlay();
    }

    function sendWebRTCMessage(data) {
      if (!ws || !currentCall) return;
      
      const message = {
        action: 'webrtc_signaling',
        data: {
          callId: currentCall.id,
          to: getOtherUserId(),
          ...data
        }
      };
      
      ws.send(JSON.stringify(message));
    }

    function getOtherUserId() {
      if (!currentCall) return null;
      return currentCall.fromUserId === currentUser.id ? currentCall.toUserId : currentCall.fromUserId;
    }

    async function handleWebRTCSignaling(data) {
      try {
        if (!peerConnection && data.type === 'offer') {
          createPeerConnection();
          if (localStream) {
            localStream.getTracks().forEach(track => {
              peerConnection.addTrack(track, localStream);
            });
          }
        }

        switch (data.type) {
          case 'offer':
            await peerConnection.setRemoteDescription(new RTCSessionDescription({
              type: 'offer',
              sdp: data.sdp
            }));
            
            // å¤„ç†ç¼“å­˜çš„ICEå€™é€‰
            for (const candidate of pendingCandidates) {
              try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
              } catch (e) {
                console.error('æ·»åŠ ICEå€™é€‰å¤±è´¥:', e);
              }
            }
            pendingCandidates = [];
            
            // åˆ›å»ºå¹¶å‘é€Answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            sendWebRTCMessage({
              type: 'answer',
              sdp: answer.sdp
            });
            break;
            
          case 'answer':
            await peerConnection.setRemoteDescription(new RTCSessionDescription({
              type: 'answer',
              sdp: data.sdp
            }));
            break;
            
          case 'candidate':
            if (!peerConnection || !peerConnection.remoteDescription) {
              pendingCandidates.push(data.candidate);
            } else {
              try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
              } catch (e) {
                console.error('æ·»åŠ ICEå€™é€‰å¤±è´¥:', e);
              }
            }
            break;
        }
      } catch (error) {
        console.error('å¤„ç†WebRTCä¿¡ä»¤å¤±è´¥:', error);
      }
    }

    function handleCallEvent(message) {
      const { action, data } = message;
      
      switch (action) {
        case 'call_incoming':
          currentCall = data;
          showIncomingCall(data);
          break;
          
        case 'call_started':
          currentCall = data;
          showCallOverlay(data, 'outgoing');
          break;
          
        case 'call_answered':
          if (currentCall) {
            currentCall.status = 'connected';
            updateCallStatus('å·²æ¥é€š');
            
            // ä¸»å«æ–¹åˆ›å»ºOffer
            if (currentCall.fromUserId === currentUser.id) {
              createPeerConnection();
              if (localStream) {
                localStream.getTracks().forEach(track => {
                  peerConnection.addTrack(track, localStream);
                });
              }
              
              (async () => {
                try {
                  const offer = await peerConnection.createOffer();
                  await peerConnection.setLocalDescription(offer);
                  
                  sendWebRTCMessage({
                    type: 'offer',
                    sdp: offer.sdp
                  });
                } catch (error) {
                  console.error('åˆ›å»ºOfferå¤±è´¥:', error);
                }
              })();
            }
          }
          break;
          
        case 'call_rejected':
          showToast('å¯¹æ–¹æ‹’ç»äº†é€šè¯');
          cleanupCall();
          break;
          
        case 'call_ended':
          showToast('é€šè¯å·²ç»“æŸ');
          cleanupCall();
          break;
          
        case 'webrtc_signaling':
          handleWebRTCSignaling(data);
          break;
      }
    }

    // é€šè¯ç•Œé¢ç®¡ç†
    function showIncomingCall(callData) {
      const callerName = callData.fromUserName || callData.fromUserId;
      const callType = callData.type === 'video' ? 'è§†é¢‘' : 'è¯­éŸ³';
      
      showCallOverlay(callData, 'incoming');
      updateCallStatus(`${callerName} é‚€è¯·æ‚¨è¿›è¡Œ${callType}é€šè¯`);
      
      // æ’­æ”¾é“ƒå£°ï¼ˆå¦‚æœéœ€è¦ï¼‰
      playRingtone();
    }

    function showCallOverlay(callData, mode) {
      const overlay = document.createElement('div');
      overlay.className = 'call-overlay';
      overlay.id = 'callOverlay';
      
      const userName = mode === 'incoming' 
        ? (callData.fromUserName || callData.fromUserId)
        : (callData.toUserName || callData.toUserId);
      
      const callType = callData.type === 'video' ? 'è§†é¢‘é€šè¯' : 'è¯­éŸ³é€šè¯';
      
      overlay.innerHTML = `
        <div class="call-container">
          <div class="call-header">
            <div class="call-title">${userName}</div>
            <div class="call-status" id="callStatus">${mode === 'incoming' ? 'æ¥ç”µ' : 'å‘¼å«ä¸­'}</div>
            <div class="call-duration" id="callDuration">00:00</div>
          </div>
          
          <div class="call-videos">
            <div class="call-video main">
              <video id="callRemoteVideo" autoplay playsinline></video>
              <div class="call-video-label">è¿œç¨‹</div>
            </div>
            <div class="call-video pip">
              <video id="callLocalVideo" autoplay muted playsinline></video>
              <div class="call-video-label">æœ¬åœ°</div>
            </div>
          </div>
          
          <div class="call-controls">
            ${mode === 'incoming' ? `
              <button class="call-btn answer" onclick="answerCall()" title="æ¥å¬">ğŸ“</button>
              <button class="call-btn decline" onclick="rejectCall()" title="æ‹’ç»">ğŸ“µ</button>
            ` : `
              <button class="call-btn mute" onclick="toggleCallMute()" id="callMuteBtn" title="é™éŸ³">ğŸ™ï¸</button>
              ${callData.type === 'video' ? `
                <button class="call-btn video" onclick="toggleCallVideo()" id="callVideoBtn" title="æ‘„åƒå¤´">ğŸ“¹</button>
              ` : ''}
              <button class="call-btn end" onclick="endCall()" title="æŒ‚æ–­">ğŸ“µ</button>
            `}
          </div>
          
          <div class="call-stats" id="callStats">
            <div class="call-stat">
              <div class="call-stat-label">éŸ³é¢‘</div>
              <div class="call-stat-value" id="audioBitrate">- kbps</div>
            </div>
            <div class="call-stat">
              <div class="call-stat-label">è§†é¢‘</div>
              <div class="call-stat-value" id="videoBitrate">- kbps</div>
            </div>
            <div class="call-stat">
              <div class="call-stat-label">å»¶è¿Ÿ</div>
              <div class="call-stat-value" id="callLatency">- ms</div>
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(overlay);
    }

    function hideCallOverlay() {
      const overlay = document.getElementById('callOverlay');
      if (overlay) {
        document.body.removeChild(overlay);
      }
    }

    function updateCallStatus(status) {
      const statusEl = document.getElementById('callStatus');
      if (statusEl) {
        statusEl.textContent = status;
      }
    }

    // é€šè¯æ§åˆ¶åŠŸèƒ½
    function toggleCallMute() {
      if (!localStream) return;
      
      const audioTrack = localStream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        const btn = document.getElementById('callMuteBtn');
        if (btn) {
          btn.classList.toggle('active', !audioTrack.enabled);
          btn.title = audioTrack.enabled ? 'é™éŸ³' : 'å–æ¶ˆé™éŸ³';
        }
      }
    }

    function toggleCallVideo() {
      if (!localStream) return;
      
      const videoTrack = localStream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        const btn = document.getElementById('callVideoBtn');
        if (btn) {
          btn.classList.toggle('active', !videoTrack.enabled);
          btn.title = videoTrack.enabled ? 'å…³é—­æ‘„åƒå¤´' : 'å¼€å¯æ‘„åƒå¤´';
        }
      }
    }

    // é€šè¯è®¡æ—¶å™¨
    function startCallTimer() {
      if (callStartTime) return;
      
      callStartTime = Date.now();
      const timer = setInterval(() => {
        if (!currentCall) {
          clearInterval(timer);
          return;
        }
        
        const duration = Date.now() - callStartTime;
        const minutes = Math.floor(duration / 60000);
        const seconds = Math.floor((duration % 60000) / 1000);
        
        const durationEl = document.getElementById('callDuration');
        if (durationEl) {
          durationEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
      }, 1000);
    }

    function stopCallTimer() {
      callStartTime = null;
    }

    // é€šè¯ç»Ÿè®¡ç›‘æ§
    function startCallStatsMonitoring() {
      if (callStatsInterval || !peerConnection) return;
      
      callStatsInterval = setInterval(async () => {
        if (!peerConnection) return;
        
        try {
          const stats = await peerConnection.getStats();
          updateCallStats(stats);
        } catch (error) {
          console.error('è·å–é€šè¯ç»Ÿè®¡å¤±è´¥:', error);
        }
      }, 2000);
    }

    function stopCallStatsMonitoring() {
      if (callStatsInterval) {
        clearInterval(callStatsInterval);
        callStatsInterval = null;
      }
    }

    function updateCallStats(stats) {
      let audioBitrate = 0, videoBitrate = 0, latency = 0;
      
      stats.forEach(report => {
        if (report.type === 'outbound-rtp') {
          if (report.kind === 'audio' && report.bytesSent) {
            audioBitrate = Math.round((report.bytesSent * 8) / 1000);
          } else if (report.kind === 'video' && report.bytesSent) {
            videoBitrate = Math.round((report.bytesSent * 8) / 1000);
          }
        } else if (report.type === 'candidate-pair' && report.state === 'succeeded') {
          if (report.currentRoundTripTime) {
            latency = Math.round(report.currentRoundTripTime * 1000);
          }
        }
      });
      
      const audioBitrateEl = document.getElementById('audioBitrate');
      const videoBitrateEl = document.getElementById('videoBitrate');
      const latencyEl = document.getElementById('callLatency');
      
      if (audioBitrateEl) audioBitrateEl.textContent = audioBitrate + ' kbps';
      if (videoBitrateEl) videoBitrateEl.textContent = videoBitrate + ' kbps';
      if (latencyEl) latencyEl.textContent = latency + ' ms';
    }

    function playRingtone() {
      // æ’­æ”¾é“ƒå£°çš„å®ç°ï¼ˆå¯é€‰ï¼‰
      if ('vibrate' in navigator) {
        navigator.vibrate([200, 100, 200]);
      }
    }

    // é€šçŸ¥
    function showNotification(message) {
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(message.fromUserName || 'æ–°æ¶ˆæ¯', {
          body: message.payload?.text || '[éæ–‡æœ¬æ¶ˆæ¯]',
          icon: '/favicon.ico'
        });
      }
    }

    function showToast(message, type = 'info') {
      // ç®€å•çš„ toast å®ç°
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--bg-secondary);
        color: var(--text-primary);
        padding: 12px 20px;
        border-radius: 8px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      toast.textContent = message;
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
          document.body.removeChild(toast);
        }, 300);
      }, 3000);
    }

    // æ·»åŠ  CSS åŠ¨ç”»
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    // è¯·æ±‚é€šçŸ¥æƒé™
    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }

    function toggleEmoji() {
      const existingPicker = document.getElementById('emojiPicker');
      if (existingPicker) {
        document.body.removeChild(existingPicker);
        return;
      }
      
      showEmojiPicker();
    }

    function showEmojiPicker() {
      const picker = document.createElement('div');
      picker.id = 'emojiPicker';
      picker.style.cssText = `
        position: fixed;
        bottom: 80px;
        left: 20px;
        right: 20px;
        max-width: 300px;
        margin: 0 auto;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 16px;
        box-shadow: var(--shadow-lg);
        z-index: 1000;
        max-height: 200px;
        overflow-y: auto;
      `;
      
      const emojis = [
        'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ˜‚', 'ğŸ¤£', 'ğŸ˜Š', 'ğŸ˜‡',
        'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Œ', 'ğŸ˜', 'ğŸ¥°', 'ğŸ˜˜', 'ğŸ˜—', 'ğŸ˜™', 'ğŸ˜š',
        'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ¤¨', 'ğŸ§', 'ğŸ¤“', 'ğŸ˜', 'ğŸ¤©',
        'ğŸ¥³', 'ğŸ˜', 'ğŸ˜’', 'ğŸ˜', 'ğŸ˜”', 'ğŸ˜Ÿ', 'ğŸ˜•', 'ğŸ™', 'â˜¹ï¸', 'ğŸ˜£',
        'ğŸ˜–', 'ğŸ˜«', 'ğŸ˜©', 'ğŸ¥º', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜¤', 'ğŸ˜ ', 'ğŸ˜¡', 'ğŸ¤¬',
        'ğŸ¤¯', 'ğŸ˜³', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ˜±', 'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜¥', 'ğŸ˜“', 'ğŸ¤—',
        'ğŸ¤”', 'ğŸ¤­', 'ğŸ¤«', 'ğŸ¤¥', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¬', 'ğŸ™„', 'ğŸ˜¯',
        'ğŸ‘', 'ğŸ‘', 'ğŸ‘Œ', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤Ÿ', 'ğŸ¤˜', 'ğŸ¤™', 'ğŸ‘ˆ', 'ğŸ‘‰',
        'ğŸ‘†', 'ğŸ–•', 'ğŸ‘‡', 'â˜ï¸', 'ğŸ‘‹', 'ğŸ¤š', 'ğŸ–ï¸', 'âœ‹', 'ğŸ––', 'ğŸ‘',
        'â¤ï¸', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ–¤', 'ğŸ¤', 'ğŸ¤', 'ğŸ’”',
        'â£ï¸', 'ğŸ’•', 'ğŸ’', 'ğŸ’“', 'ğŸ’—', 'ğŸ’–', 'ğŸ’˜', 'ğŸ’', 'ğŸ’Ÿ', 'â™¥ï¸'
      ];
      
      picker.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <span style="font-weight: 600; color: var(--text-primary);">é€‰æ‹©è¡¨æƒ…</span>
          <button onclick="closeEmojiPicker()" style="background: none; border: none; color: var(--text-quaternary); cursor: pointer; font-size: 18px;">âœ•</button>
        </div>
        <div style="display: grid; grid-template-columns: repeat(10, 1fr); gap: 8px;">
          ${emojis.map(emoji => `
            <button onclick="insertEmoji('${emoji}')" style="
              background: none; 
              border: none; 
              font-size: 20px; 
              padding: 8px; 
              border-radius: 8px; 
              cursor: pointer;
              transition: var(--transition);
            " onmouseover="this.style.background='var(--bg-overlay)'" onmouseout="this.style.background='none'">${emoji}</button>
          `).join('')}
        </div>
      `;
      
      document.body.appendChild(picker);
      
      // ç‚¹å‡»å¤–éƒ¨å…³é—­
      setTimeout(() => {
        document.addEventListener('click', function closeOnClickOutside(e) {
          if (!picker.contains(e.target) && e.target.getAttribute('data-tooltip') !== 'è¡¨æƒ…') {
            closeEmojiPicker();
            document.removeEventListener('click', closeOnClickOutside);
          }
        });
      }, 100);
    }

    function closeEmojiPicker() {
      const picker = document.getElementById('emojiPicker');
      if (picker) {
        document.body.removeChild(picker);
      }
    }

    function insertEmoji(emoji) {
      const input = document.getElementById('messageInput');
      const start = input.selectionStart;
      const end = input.selectionEnd;
      const text = input.value;
      
      input.value = text.substring(0, start) + emoji + text.substring(end);
      input.selectionStart = input.selectionEnd = start + emoji.length;
      
      // è§¦å‘è¾“å…¥äº‹ä»¶ä»¥æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
      updateSendButton();
      autoResizeInput();
      input.focus();
      
      closeEmojiPicker();
    }

    // è”ç³»äººç®¡ç†åŠŸèƒ½
    function createContactItem(contact) {
      const div = document.createElement('div');
      div.className = 'conversation-item';
      div.onclick = () => startConversationWithContact(contact);
      
      const avatar = (contact.remark || contact.nickname || contact.username)?.charAt(0)?.toUpperCase() || '?';
      const displayName = contact.remark || contact.nickname || contact.username || contact.id;
      const subTitle = contact.remark ? `${contact.username}` : (contact.online ? 'åœ¨çº¿' : 'ç¦»çº¿');
      
      div.innerHTML = `
        <div class="conversation-avatar">
          ${avatar}
          ${contact.online ? '<div class="online-indicator"></div>' : ''}
        </div>
        <div class="conversation-info">
          <div class="conversation-name">${displayName}</div>
          <div class="conversation-preview">${subTitle}</div>
        </div>
        <div class="conversation-meta">
          <button class="icon-btn" onclick="event.stopPropagation(); editContactRemark('${contact.id}', '${displayName}', '${contact.remark || ''}')" style="margin-right: 4px;" title="ç¼–è¾‘å¤‡æ³¨">âœï¸</button>
          <button class="icon-btn" onclick="event.stopPropagation(); removeContact('${contact.id}')" title="åˆ é™¤å¥½å‹">ğŸ—‘ï¸</button>
        </div>
      `;
      
      return div;
    }

    function showAddContactDialog() {
      const dialog = document.createElement('div');
      dialog.className = 'login-modal';
      dialog.innerHTML = `
        <div class="login-form" style="max-width: 500px; max-height: 70vh; overflow: hidden; display: flex; flex-direction: column;">
          <div class="login-header">
            <h2 class="login-title">æ·»åŠ å¥½å‹</h2>
            <p class="login-subtitle">æœç´¢ç”¨æˆ·åæˆ–æ˜µç§°</p>
          </div>
          
          <div class="form-group">
            <input type="text" class="form-input" id="searchUserInput" placeholder="è¾“å…¥ç”¨æˆ·åæˆ–æ˜µç§°æœç´¢" 
                   oninput="searchUsersForAdd()" autocomplete="off">
          </div>
          
          <div id="searchResultsList" style="flex: 1; overflow-y: auto; min-height: 200px; max-height: 300px; border: 1px solid var(--border); border-radius: 8px; margin: 10px 0;">
            <div class="empty-state" style="padding: 40px 20px; text-align: center; color: var(--text-secondary);">
              <div style="font-size: 24px; margin-bottom: 10px;">ğŸ”</div>
              <div>è¾“å…¥å…³é”®è¯å¼€å§‹æœç´¢</div>
            </div>
          </div>
          
          <div class="form-group" style="margin-top: auto;">
            <button class="btn btn-secondary" onclick="closeAddContactDialog()">å–æ¶ˆ</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(dialog);
      document.getElementById('searchUserInput').focus();
    }

    function closeAddContactDialog() {
      const dialog = document.querySelector('.login-modal');
      if (dialog) {
        document.body.removeChild(dialog);
      }
    }

    // é˜²æŠ–æœç´¢
    let searchTimeout = null;
    
    function searchUsersForAdd() {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(async () => {
        const query = document.getElementById('searchUserInput').value.trim();
        
        if (query.length < 2) {
          const resultsList = document.getElementById('searchResultsList');
          resultsList.innerHTML = `
            <div class="empty-state" style="padding: 40px 20px; text-align: center; color: var(--text-secondary);">
              <div style="font-size: 24px; margin-bottom: 10px;">ğŸ”</div>
              <div>è¾“å…¥è‡³å°‘2ä¸ªå­—ç¬¦å¼€å§‹æœç´¢</div>
            </div>
          `;
          return;
        }
        
        try {
          const response = await apiRequest(`/api/users/search?q=${encodeURIComponent(query)}`);
          renderSearchResults(response.users || []);
        } catch (error) {
          console.error('Search users error:', error);
          const resultsList = document.getElementById('searchResultsList');
          resultsList.innerHTML = `
            <div class="empty-state" style="padding: 40px 20px; text-align: center; color: var(--text-secondary);">
              <div style="font-size: 24px; margin-bottom: 10px;">âŒ</div>
              <div>æœç´¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•</div>
            </div>
          `;
        }
      }, 300);
    }
    
    function renderSearchResults(users) {
      const resultsList = document.getElementById('searchResultsList');
      
      if (users.length === 0) {
        resultsList.innerHTML = `
          <div class="empty-state" style="padding: 40px 20px; text-align: center; color: var(--text-secondary);">
            <div style="font-size: 24px; margin-bottom: 10px;">ğŸ˜”</div>
            <div>æœªæ‰¾åˆ°åŒ¹é…çš„ç”¨æˆ·</div>
          </div>
        `;
        return;
      }
      
      resultsList.innerHTML = users.map(user => {
        const avatar = (user.nickname || user.username)?.charAt(0)?.toUpperCase() || '?';
        const displayName = user.nickname || user.username;
        const subTitle = user.nickname ? user.username : user.id;
        const isFriend = user.isFriend;
        
        return `
          <div class="conversation-item" style="cursor: pointer; border-bottom: 1px solid var(--border);">
            <div class="conversation-avatar">
              ${avatar}
            </div>
            <div class="conversation-info">
              <div class="conversation-name">${displayName}</div>
              <div class="conversation-preview" style="font-size: 12px; color: var(--text-secondary);">${subTitle}</div>
            </div>
            <div class="conversation-meta">
              ${isFriend 
                ? '<span style="color: var(--success); font-size: 12px;">å·²æ˜¯å¥½å‹</span>'
                : `<button class="btn" style="font-size: 12px; padding: 4px 12px;" onclick="showAddFriendConfirm('${user.id}', '${displayName}')">æ·»åŠ </button>`
              }
            </div>
          </div>
        `;
      }).join('');
    }
    
    function showAddFriendConfirm(userId, displayName) {
      const confirmDialog = document.createElement('div');
      confirmDialog.className = 'login-modal';
      confirmDialog.innerHTML = `
        <div class="login-form" style="max-width: 400px;">
          <div class="login-header">
            <h2 class="login-title">æ·»åŠ å¥½å‹</h2>
            <p class="login-subtitle">ç¡®è®¤æ·»åŠ  ${displayName} ä¸ºå¥½å‹</p>
          </div>
          
          <div class="form-group">
            <input type="text" class="form-input" id="friendRemarkInput" placeholder="å¤‡æ³¨åç§°ï¼ˆå¯é€‰ï¼‰" maxlength="20">
          </div>
          
          <div class="form-group">
            <button class="btn" onclick="confirmAddFriend('${userId}')">ç¡®è®¤æ·»åŠ </button>
          </div>
          
          <div class="form-group">
            <button class="btn btn-secondary" onclick="closeAddFriendConfirm()">å–æ¶ˆ</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(confirmDialog);
      document.getElementById('friendRemarkInput').focus();
    }
    
    function closeAddFriendConfirm() {
      const dialogs = document.querySelectorAll('.login-modal');
      if (dialogs.length > 1) {
        // å…³é—­ç¡®è®¤å¯¹è¯æ¡†ï¼Œä¿ç•™æœç´¢å¯¹è¯æ¡†
        document.body.removeChild(dialogs[dialogs.length - 1]);
      }
    }
    
    async function confirmAddFriend(userId) {
      const remark = document.getElementById('friendRemarkInput').value.trim();
      
      try {
        await apiRequest('/api/friends', {
          method: 'POST',
          body: JSON.stringify({
            friendID: userId,
            remark: remark
          })
        });
        
        showToast('å¥½å‹æ·»åŠ æˆåŠŸ');
        closeAddFriendConfirm();
        closeAddContactDialog();
        
        // åˆ·æ–°è”ç³»äººåˆ—è¡¨
        if (document.querySelector('[data-tab="contacts"]').classList.contains('active')) {
          loadContacts().then(() => renderContactList());
        }
        
      } catch (error) {
        console.error('Add friend error:', error);
        showToast('æ·»åŠ å¥½å‹å¤±è´¥ï¼š' + (error.message || 'è¯·ç¨åé‡è¯•'));
      }
    }

    // ä¿ç•™åŸæœ‰çš„æ·»åŠ å‡½æ•°ä½œä¸ºå¤‡ç”¨
    async function addContact() {
      const input = document.getElementById('addContactInput')?.value?.trim();
      const remark = document.getElementById('addContactRemark')?.value?.trim();
      
      if (!input) {
        showToast('è¯·è¾“å…¥ç”¨æˆ·IDæˆ–ç”¨æˆ·å');
        return;
      }
      
      try {
        const response = await apiRequest('/api/friends', {
          method: 'POST',
          body: JSON.stringify({
            friendID: input,
            remark: remark
          })
        });
        
        showToast('å¥½å‹è¯·æ±‚å·²å‘é€');
        closeAddContactDialog();
        
        // åˆ·æ–°è”ç³»äººåˆ—è¡¨
        if (document.querySelector('[data-tab="contacts"]').classList.contains('active')) {
          loadContacts().then(() => renderContactList());
        }
      } catch (error) {
        console.error('Add contact error:', error);
        showToast('æ·»åŠ å¥½å‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·IDæ˜¯å¦æ­£ç¡®');
      }
    }

    async function removeContact(contactId) {
      if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè”ç³»äººå—ï¼Ÿ')) return;
      
      try {
        await apiRequest(`/api/friends/${contactId}`, { method: 'DELETE' });
        
        contacts.delete(contactId);
        showToast('è”ç³»äººå·²åˆ é™¤');
        renderContactList();
      } catch (error) {
        console.error('Remove contact error:', error);
        showToast('åˆ é™¤è”ç³»äººå¤±è´¥');
      }
    }

    function editContactRemark(contactId, displayName, currentRemark) {
      const dialog = document.createElement('div');
      dialog.className = 'login-modal';
      dialog.innerHTML = `
        <div class="login-form">
          <div class="login-header">
            <h2 class="login-title">ç¼–è¾‘å¤‡æ³¨</h2>
            <p class="login-subtitle">${displayName}</p>
          </div>
          
          <div class="form-group">
            <input type="text" class="form-input" id="editRemarkInput" placeholder="è¾“å…¥å¤‡æ³¨åç§°" value="${currentRemark}">
          </div>
          
          <div class="form-group">
            <button class="btn" onclick="saveContactRemark('${contactId}')">ä¿å­˜å¤‡æ³¨</button>
          </div>
          
          <div class="form-group">
            <button class="btn btn-secondary" onclick="closeEditRemarkDialog()">å–æ¶ˆ</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(dialog);
      document.getElementById('editRemarkInput').focus();
      document.getElementById('editRemarkInput').select();
    }

    function closeEditRemarkDialog() {
      const dialog = document.querySelector('.login-modal');
      if (dialog) {
        document.body.removeChild(dialog);
      }
    }

    async function saveContactRemark(contactId) {
      const remark = document.getElementById('editRemarkInput').value.trim();
      
      try {
        await apiRequest(`/api/friends/${contactId}`, {
          method: 'PUT',
          body: JSON.stringify({
            remark: remark
          })
        });
        
        // æ›´æ–°æœ¬åœ°æ•°æ®
        const contact = contacts.get(contactId);
        if (contact) {
          contact.remark = remark;
          contacts.set(contactId, contact);
        }
        
        showToast('å¤‡æ³¨å·²ä¿å­˜');
        closeEditRemarkDialog();
        renderContactList();
        
      } catch (error) {
        console.error('Save remark error:', error);
        showToast('ä¿å­˜å¤‡æ³¨å¤±è´¥');
      }
    }

    function startConversationWithContact(contact) {
      // åˆ›å»ºæˆ–æ‰¾åˆ°ä¸è¯¥è”ç³»äººçš„ä¼šè¯
      const convId = `c2c-${currentUser.id}-${contact.id}`;
      
      const conversation = {
        convId: convId,
        type: 'c2c',
        name: contact.nickname || contact.username,
        userId: contact.id,
        online: contact.online,
        unreadCount: 0
      };
      
      conversations.set(convId, conversation);
      selectConversation(conversation);
      
      // åˆ‡æ¢åˆ°èŠå¤©æ ‡ç­¾
      switchTab('chats');
    }

    // ç¾¤ç»„ç®¡ç†åŠŸèƒ½
    function createGroupItem(group) {
      const div = document.createElement('div');
      div.className = 'conversation-item';
      div.onclick = () => startConversationWithGroup(group);
      
      const avatar = group.name?.charAt(0)?.toUpperCase() || 'ç¾¤';
      const name = group.name || group.id;
      const memberInfo = `${group.memberCount || 0} åæˆå‘˜`;
      const roleText = group.role === 'owner' ? 'ç¾¤ä¸»' : (group.role === 'admin' ? 'ç®¡ç†å‘˜' : 'æˆå‘˜');
      const statusText = group.muted ? 'å·²ç¦è¨€' : roleText;
      
      div.innerHTML = `
        <div class="conversation-avatar" style="background: var(--warning);">
          ${avatar}
          ${group.muted ? '<div class="mute-indicator" style="position: absolute; bottom: 0; right: 0; width: 12px; height: 12px; background: var(--danger); border-radius: 50%; border: 2px solid white;"></div>' : ''}
        </div>
        <div class="conversation-info">
          <div class="conversation-name">${name}</div>
          <div class="conversation-preview">${memberInfo} â€¢ ${statusText}</div>
        </div>
        <div class="conversation-meta">
          <button class="icon-btn" onclick="event.stopPropagation(); showGroupInfo('${group.id}')" title="ç¾¤ç»„ä¿¡æ¯">â„¹ï¸</button>
        </div>
      `;
      
      return div;
    }

    function showCreateGroupDialog() {
      const dialog = document.createElement('div');
      dialog.className = 'login-modal';
      dialog.innerHTML = `
        <div class="login-form">
          <div class="login-header">
            <h2 class="login-title">åˆ›å»ºç¾¤ç»„</h2>
            <p class="login-subtitle">åˆ›å»ºä¸€ä¸ªæ–°çš„ç¾¤èŠ</p>
          </div>
          
          <div class="form-group">
            <input type="text" class="form-input" id="createGroupName" placeholder="ç¾¤ç»„åç§°">
          </div>
          
          <div class="form-group">
            <input type="text" class="form-input" id="createGroupDesc" placeholder="ç¾¤ç»„æè¿°ï¼ˆå¯é€‰ï¼‰">
          </div>
          
          <div class="form-group">
            <button class="btn" onclick="createGroup()">åˆ›å»ºç¾¤ç»„</button>
          </div>
          
          <div class="form-group">
            <button class="btn btn-secondary" onclick="closeCreateGroupDialog()">å–æ¶ˆ</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(dialog);
      document.getElementById('createGroupName').focus();
    }

    function closeCreateGroupDialog() {
      const dialog = document.querySelector('.login-modal');
      if (dialog) {
        document.body.removeChild(dialog);
      }
    }

    async function createGroup() {
      const name = document.getElementById('createGroupName').value.trim();
      const description = document.getElementById('createGroupDesc').value.trim();
      
      if (!name) {
        showToast('è¯·è¾“å…¥ç¾¤ç»„åç§°');
        return;
      }
      
      try {
        const response = await apiRequest('/api/groups', {
          method: 'POST',
          body: JSON.stringify({
            name: name,
            description: description
          })
        });
        
        if (response.groupId) {
          showToast('ç¾¤ç»„åˆ›å»ºæˆåŠŸ');
          closeCreateGroupDialog();
          
          // åˆ·æ–°ç¾¤ç»„åˆ—è¡¨
          if (document.querySelector('[data-tab="groups"]').classList.contains('active')) {
            loadGroups().then(() => renderGroupList());
          }
        }
      } catch (error) {
        console.error('Create group error:', error);
        showToast('åˆ›å»ºç¾¤ç»„å¤±è´¥');
      }
    }

    function showJoinGroupDialog() {
      const dialog = document.createElement('div');
      dialog.className = 'login-modal';
      dialog.innerHTML = `
        <div class="login-form">
          <div class="login-header">
            <h2 class="login-title">åŠ å…¥ç¾¤ç»„</h2>
            <p class="login-subtitle">è¾“å…¥ç¾¤ç»„ID</p>
          </div>
          
          <div class="form-group">
            <input type="text" class="form-input" id="joinGroupId" placeholder="ç¾¤ç»„ID">
          </div>
          
          <div class="form-group">
            <button class="btn" onclick="joinGroup()">åŠ å…¥ç¾¤ç»„</button>
          </div>
          
          <div class="form-group">
            <button class="btn btn-secondary" onclick="closeJoinGroupDialog()">å–æ¶ˆ</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(dialog);
      document.getElementById('joinGroupId').focus();
    }

    function closeJoinGroupDialog() {
      const dialog = document.querySelector('.login-modal');
      if (dialog) {
        document.body.removeChild(dialog);
      }
    }

    async function joinGroup() {
      const groupId = document.getElementById('joinGroupId').value.trim();
      
      if (!groupId) {
        showToast('è¯·è¾“å…¥ç¾¤ç»„ID');
        return;
      }
      
      try {
        const response = await apiRequest(`/api/groups/${groupId}/join`, {
          method: 'POST'
        });
        
        showToast('å·²åŠ å…¥ç¾¤ç»„');
        closeJoinGroupDialog();
        
        // åˆ·æ–°ç¾¤ç»„åˆ—è¡¨
        if (document.querySelector('[data-tab="groups"]').classList.contains('active')) {
          loadGroups().then(() => renderGroupList());
        }
      } catch (error) {
        console.error('Join group error:', error);
        showToast('åŠ å…¥ç¾¤ç»„å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç¾¤ç»„IDæ˜¯å¦æ­£ç¡®');
      }
    }

    function startConversationWithGroup(group) {
      // åˆ›å»ºæˆ–æ‰¾åˆ°ä¸è¯¥ç¾¤ç»„çš„ä¼šè¯
      const convId = `group-${group.id}`;
      
      const conversation = {
        convId: convId,
        type: 'group',
        name: group.name,
        groupId: group.id,
        memberCount: group.memberCount,
        unreadCount: 0
      };
      
      conversations.set(convId, conversation);
      selectConversation(conversation);
      
      // è®¢é˜…ç¾¤ç»„æ¶ˆæ¯
      if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({
          action: 'subscribe_group',
          data: { groupId: group.id }
        }));
      }
      
      // åˆ‡æ¢åˆ°èŠå¤©æ ‡ç­¾
      switchTab('chats');
    }

    function showGroupInfo(groupId) {
      showToast('ç¾¤ç»„ä¿¡æ¯åŠŸèƒ½å¼€å‘ä¸­...');
    }

    // PWA å’Œ Service Worker åŠŸèƒ½
    async function registerServiceWorker() {
      if ('serviceWorker' in navigator) {
        try {
          const registration = await navigator.serviceWorker.register('/sw.js');
          console.log('Service Worker æ³¨å†ŒæˆåŠŸ:', registration);
          
          // ç›‘å¬ Service Worker æ›´æ–°
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // æœ‰æ–°ç‰ˆæœ¬å¯ç”¨
                  showUpdatePrompt();
                }
              });
            }
          });
          
          // ç›‘å¬æ¥è‡ª Service Worker çš„æ¶ˆæ¯
          navigator.serviceWorker.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'VERSION') {
              console.log('Service Worker ç‰ˆæœ¬:', event.data.version);
            }
          });
          
        } catch (error) {
          console.error('Service Worker æ³¨å†Œå¤±è´¥:', error);
        }
      }
    }

    function showUpdatePrompt() {
      if (confirm('å‘ç°æ–°ç‰ˆæœ¬ï¼Œæ˜¯å¦ç«‹å³æ›´æ–°ï¼Ÿ')) {
        if (navigator.serviceWorker.controller) {
          navigator.serviceWorker.controller.postMessage({ type: 'SKIP_WAITING' });
          window.location.reload();
        }
      }
    }

    let deferredPrompt = null;

    function setupPWAInstallPrompt() {
      // ç›‘å¬å®‰è£…æç¤ºäº‹ä»¶
      window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        showInstallButton();
      });

      // ç›‘å¬åº”ç”¨å®‰è£…äº‹ä»¶
      window.addEventListener('appinstalled', () => {
        console.log('PWA å·²å®‰è£…');
        hideInstallButton();
        showToast('åº”ç”¨å·²å®‰è£…åˆ°è®¾å¤‡');
      });

      // æ£€æŸ¥æ˜¯å¦å·²åœ¨ç‹¬ç«‹æ¨¡å¼è¿è¡Œ
      if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
        console.log('PWA è¿è¡Œåœ¨ç‹¬ç«‹æ¨¡å¼');
        hideInstallButton();
      }
    }

    function showInstallButton() {
      // åˆ›å»ºå®‰è£…æŒ‰é’®
      const installBtn = document.createElement('button');
      installBtn.id = 'installBtn';
      installBtn.className = 'icon-btn tooltip';
      installBtn.setAttribute('data-tooltip', 'å®‰è£…åº”ç”¨');
      installBtn.innerHTML = 'ğŸ“±';
      installBtn.onclick = () => installPWA();
      
      // æ·»åŠ åˆ°ç”¨æˆ·æ“ä½œåŒºåŸŸ
      const userActions = document.querySelector('.user-actions');
      if (userActions && !document.getElementById('installBtn')) {
        userActions.insertBefore(installBtn, userActions.firstChild);
      }
    }

    function hideInstallButton() {
      const installBtn = document.getElementById('installBtn');
      if (installBtn) {
        installBtn.remove();
      }
    }

    async function installPWA() {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        
        if (outcome === 'accepted') {
          console.log('ç”¨æˆ·æ¥å—äº†å®‰è£…');
          showToast('æ­£åœ¨å®‰è£…åº”ç”¨...');
        } else {
          console.log('ç”¨æˆ·æ‹’ç»äº†å®‰è£…');
        }
        
        deferredPrompt = null;
        hideInstallButton();
      }
    }

    // ç¦»çº¿çŠ¶æ€æ£€æµ‹
    function setupOfflineDetection() {
      window.addEventListener('online', () => {
        showToast('ç½‘ç»œå·²è¿æ¥');
        if (currentUser && !isConnected) {
          connectWebSocket();
        }
      });

      window.addEventListener('offline', () => {
        showToast('ç½‘ç»œå·²æ–­å¼€ï¼Œæ­£åœ¨å°è¯•é‡è¿...');
      });
    }

    // è°ƒç”¨ç¦»çº¿æ£€æµ‹è®¾ç½®
    setupOfflineDetection();

    // é«˜çº§æ¶ˆæ¯åŠŸèƒ½å®ç°
    
    // æ¶ˆæ¯å¼•ç”¨åŠŸèƒ½
    function replyToMessageFunc(message) {
      replyToMessage = message;
      
      const replyPreview = document.getElementById('replyPreview');
      const replyAuthor = document.getElementById('replyAuthor');
      const replyContent = document.getElementById('replyContent');
      
      if (replyPreview && replyAuthor && replyContent) {
        replyAuthor.textContent = message.fromUserName || message.fromUserId || 'ç”¨æˆ·';
        replyContent.textContent = getMessagePreviewText(message);
        replyPreview.classList.remove('hidden');
        
        // èšç„¦åˆ°è¾“å…¥æ¡†
        const messageInput = document.getElementById('messageInput');
        if (messageInput) {
          messageInput.focus();
        }
      }
    }

    function cancelReply() {
      replyToMessage = null;
      const replyPreview = document.getElementById('replyPreview');
      if (replyPreview) {
        replyPreview.classList.add('hidden');
      }
    }

    function getMessagePreviewText(message) {
      switch (message.type) {
        case 'text':
          return message.payload?.text || '';
        case 'image':
          return '[å›¾ç‰‡]';
        case 'file':
          return '[æ–‡ä»¶] ' + (message.payload?.name || '');
        case 'voice':
          return '[è¯­éŸ³]';
        case 'video':
          return '[è§†é¢‘]';
        default:
          return '[æ¶ˆæ¯]';
      }
    }

    // æ¶ˆæ¯æ’¤å›åŠŸèƒ½
    async function recallMessage(messageId, messageSeq) {
      if (!currentConversation) return;
      
      try {
        // å‘é€æ’¤å›è¯·æ±‚åˆ°æœåŠ¡å™¨
        const message = {
          action: 'recall_message',
          data: {
            convId: currentConversation.convId,
            messageId: messageId,
            seq: messageSeq
          }
        };
        
        ws.send(JSON.stringify(message));
        
        // æœ¬åœ°ç«‹å³æ›´æ–°UI
        updateMessageAsRecalled(messageId);
        
      } catch (error) {
        console.error('æ’¤å›æ¶ˆæ¯å¤±è´¥:', error);
        showToast('æ’¤å›æ¶ˆæ¯å¤±è´¥');
      }
    }

    function updateMessageAsRecalled(messageId) {
      const messageElements = document.querySelectorAll(`.message-group[data-message-id="${messageId}"]`);
      messageElements.forEach(el => {
        el.classList.add('message-recalled');
        const bubble = el.querySelector('.message-bubble');
        if (bubble) {
          bubble.textContent = 'æ­¤æ¶ˆæ¯å·²è¢«æ’¤å›';
        }
      });
    }

    // @æåŠåŠŸèƒ½
    function setupMentionSupport() {
      const messageInput = document.getElementById('messageInput');
      if (!messageInput) return;
      
      messageInput.addEventListener('input', handleMentionInput);
      messageInput.addEventListener('keydown', handleMentionKeydown);
    }

    function handleMentionInput(event) {
      const input = event.target;
      const text = input.value;
      const cursorPos = input.selectionStart;
      
      // æ£€æŸ¥æ˜¯å¦è¾“å…¥äº†@
      const beforeCursor = text.substring(0, cursorPos);
      const mentionMatch = beforeCursor.match(/@(\w*)$/);
      
      if (mentionMatch) {
        const query = mentionMatch[1];
        showMentionPicker(query, input);
      } else {
        hideMentionPicker();
      }
    }

    function handleMentionKeydown(event) {
      if (!mentionPicker || mentionUsers.length === 0) return;
      
      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          selectedMentionIndex = Math.min(selectedMentionIndex + 1, mentionUsers.length - 1);
          updateMentionSelection();
          break;
          
        case 'ArrowUp':
          event.preventDefault();
          selectedMentionIndex = Math.max(selectedMentionIndex - 1, 0);
          updateMentionSelection();
          break;
          
        case 'Enter':
        case 'Tab':
          event.preventDefault();
          if (selectedMentionIndex >= 0 && selectedMentionIndex < mentionUsers.length) {
            insertMention(mentionUsers[selectedMentionIndex]);
          }
          break;
          
        case 'Escape':
          event.preventDefault();
          hideMentionPicker();
          break;
      }
    }

    function showMentionPicker(query, input) {
      // è·å–å¯@çš„ç”¨æˆ·åˆ—è¡¨
      const availableUsers = getMentionableUsers(query);
      
      if (availableUsers.length === 0) {
        hideMentionPicker();
        return;
      }
      
      mentionUsers = availableUsers;
      selectedMentionIndex = 0;
      
      // åˆ›å»ºæˆ–æ›´æ–°é€‰æ‹©å™¨
      if (!mentionPicker) {
        mentionPicker = document.createElement('div');
        mentionPicker.className = 'mention-picker';
        mentionPicker.id = 'mentionPicker';
        document.body.appendChild(mentionPicker);
      }
      
      // æ¸²æŸ“ç”¨æˆ·åˆ—è¡¨
      mentionPicker.innerHTML = availableUsers.map((user, index) => {
        const avatar = (user.nickname || user.username)?.charAt(0)?.toUpperCase() || '?';
        return `
          <div class="mention-item ${index === selectedMentionIndex ? 'selected' : ''}" 
               onclick="insertMention(mentionUsers[${index}])">
            <div class="mention-avatar">${avatar}</div>
            <div class="mention-info">
              <div class="mention-name">${user.nickname || user.username}</div>
              <div class="mention-username">@${user.username}</div>
            </div>
          </div>
        `;
      }).join('');
      
      // å®šä½é€‰æ‹©å™¨
      positionMentionPicker(input);
    }

    function hideMentionPicker() {
      if (mentionPicker) {
        document.body.removeChild(mentionPicker);
        mentionPicker = null;
      }
      mentionUsers = [];
      selectedMentionIndex = -1;
    }

    function updateMentionSelection() {
      if (!mentionPicker) return;
      
      const items = mentionPicker.querySelectorAll('.mention-item');
      items.forEach((item, index) => {
        item.classList.toggle('selected', index === selectedMentionIndex);
      });
    }

    function positionMentionPicker(input) {
      if (!mentionPicker) return;
      
      const rect = input.getBoundingClientRect();
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      
      mentionPicker.style.position = 'absolute';
      mentionPicker.style.left = rect.left + 'px';
      mentionPicker.style.top = (rect.top + scrollTop - mentionPicker.offsetHeight - 8) + 'px';
      mentionPicker.style.zIndex = '1000';
    }

    function getMentionableUsers(query) {
      const users = [];
      
      // ä»è”ç³»äººä¸­ç­›é€‰
      contacts.forEach(contact => {
        if (!query || 
            (contact.username && contact.username.toLowerCase().includes(query.toLowerCase())) ||
            (contact.nickname && contact.nickname.toLowerCase().includes(query.toLowerCase()))) {
          users.push(contact);
        }
      });
      
      // å¦‚æœæ˜¯ç¾¤èŠï¼Œå¯ä»¥æ·»åŠ ç¾¤æˆå‘˜
      if (currentConversation && currentConversation.type === 'group') {
        // è¿™é‡Œå¯ä»¥æ·»åŠ è·å–ç¾¤æˆå‘˜çš„é€»è¾‘
      }
      
      return users.slice(0, 10); // é™åˆ¶æ˜¾ç¤ºæ•°é‡
    }

    function insertMention(user) {
      const input = document.getElementById('messageInput');
      if (!input) return;
      
      const text = input.value;
      const cursorPos = input.selectionStart;
      const beforeCursor = text.substring(0, cursorPos);
      const afterCursor = text.substring(cursorPos);
      
      // æ‰¾åˆ°@çš„ä½ç½®
      const mentionMatch = beforeCursor.match(/@(\w*)$/);
      if (!mentionMatch) return;
      
      const mentionStart = beforeCursor.lastIndexOf('@');
      const mentionText = `@${user.username} `;
      
      // æ›¿æ¢æ–‡æœ¬
      const newText = beforeCursor.substring(0, mentionStart) + mentionText + afterCursor;
      input.value = newText;
      
      // è®¾ç½®å…‰æ ‡ä½ç½®
      const newCursorPos = mentionStart + mentionText.length;
      input.selectionStart = input.selectionEnd = newCursorPos;
      
      // éšè—é€‰æ‹©å™¨
      hideMentionPicker();
      
      // æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
      updateSendButton();
      autoResizeInput();
      input.focus();
    }

    // æ¶ˆæ¯æ“ä½œèœå•
    function showMessageMenu(event, message) {
      event.preventDefault();
      event.stopPropagation();
      
      // ç§»é™¤ç°æœ‰èœå•
      hideMessageMenu();
      
      const menu = document.createElement('div');
      menu.className = 'message-menu';
      menu.id = 'messageMenu';
      
      const isSentByMe = message.fromUserId === currentUser.id;
      const canRecall = isSentByMe && isRecentMessage(message);
      
      const menuItems = [
        {
          text: 'å¼•ç”¨',
          icon: 'â†©ï¸',
          action: () => {
            replyToMessageFunc(message);
            hideMessageMenu();
          }
        },
        {
          text: 'å¤åˆ¶',
          icon: 'ğŸ“‹',
          action: () => {
            copyMessageText(message);
            hideMessageMenu();
          }
        }
      ];
      
      if (canRecall) {
        menuItems.push({
          text: 'æ’¤å›',
          icon: 'â†¶',
          class: 'danger',
          action: () => {
            recallMessage(message.id, message.seq);
            hideMessageMenu();
          }
        });
      }
      
      menu.innerHTML = menuItems.map(item => `
        <div class="message-menu-item ${item.class || ''}" onclick="(${item.action})()">
          <span>${item.icon}</span>
          <span>${item.text}</span>
        </div>
      `).join('');
      
      // å®šä½èœå•
      const rect = event.target.getBoundingClientRect();
      menu.style.position = 'absolute';
      menu.style.left = rect.left + 'px';
      menu.style.top = (rect.top - menu.offsetHeight) + 'px';
      
      document.body.appendChild(menu);
      messageMenu = menu;
      
      // ç‚¹å‡»å¤–éƒ¨å…³é—­èœå•
      setTimeout(() => {
        document.addEventListener('click', hideMessageMenu, { once: true });
      }, 100);
    }

    function hideMessageMenu() {
      if (messageMenu) {
        document.body.removeChild(messageMenu);
        messageMenu = null;
      }
    }

    function isRecentMessage(message) {
      // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦æ˜¯æœ€è¿‘å‘é€çš„ï¼ˆæ¯”å¦‚5åˆ†é’Ÿå†…ï¼‰
      const messageTime = new Date(message.createdAt).getTime();
      const now = Date.now();
      return (now - messageTime) < 5 * 60 * 1000; // 5åˆ†é’Ÿ
    }

    function copyMessageText(message) {
      const text = getMessagePreviewText(message);
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
          showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
        });
      } else {
        // é™çº§æ–¹æ¡ˆ
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
      }
    }

    // æ¸²æŸ“å¸¦æœ‰@æåŠçš„æ¶ˆæ¯æ–‡æœ¬
    function renderMessageWithMentions(text) {
      if (!text) return '';
      
      // åŒ¹é…@ç”¨æˆ·åçš„æ­£åˆ™è¡¨è¾¾å¼
      const mentionRegex = /@(\w+)/g;
      
      return text.replace(mentionRegex, (match, username) => {
        return `<span class="mention">${match}</span>`;
      });
    }

    // åˆå§‹åŒ–@æåŠæ”¯æŒ
    setTimeout(() => {
      setupMentionSupport();
    }, 1000);

    // æ¶ˆæ¯æ’¤å›å¤„ç†
    function handleMessageRecalled(data) {
      console.log('Message recalled:', data);
      
      if (data.messageId) {
        updateMessageAsRecalled(data.messageId);
      }
      
      // å¦‚æœå½“å‰æ­£åœ¨å¼•ç”¨è¿™æ¡æ¶ˆæ¯ï¼Œå–æ¶ˆå¼•ç”¨
      if (replyToMessage && replyToMessage.id === data.messageId) {
        cancelReply();
      }
    }

    // åˆå§‹åŒ–WebRTC
    setTimeout(() => {
      initWebRTC();
    }, 1000);
  </script>
</body>
</html>
